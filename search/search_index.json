{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Getting started with AI on IBM Z and LinuxONE systems","text":"<p>IBM Z and LinuxONE feature state of the art hardware and software capabilities designed to optimize AI at scale alongside your enterprise's most critical workloads and data. </p> <p>AI on IBM Z and LinuxONE is a large umbrella that covers both server technology as well as numerous IBM and vendor offerings and open-source projects. This includes enhancements such as the IBM Telum on-chip inference accelerator used by IBM z16 and LinuxONE 4 systems. </p> <p>This github page is designed to help you get jump started on leveraging AI. It features information on how to leverage the best of the open source ecosystem on IBM Z and LinuxONE, as well as pointers to community edition and freely available software that can help you quickly get started. It additionally provides example use cases, code samples, and other content to serve as a technical resource for your AI on Z journey. </p> <p>Use the navigation bar on the left to select the most apporpriate topic. For other questions, reach out directly to aionz@us.ibm.com</p>"},{"location":"codingAIU/","title":"Compiler and AI framework developer resources","text":""},{"location":"codingAIU/#developing-for-the-integrated-accelerator-for-ai","title":"Developing for the Integrated Accelerator for AI","text":"<p>Most users of the IBM z16 Integrated Accelerator for AI will be accessing it through frameworks and technologies like the IBM Deep Learning Compiler, TensorFlow, or Snap ML. The other pages on this site are focused on this type of usage. Information on using these can be found throughout these pages. </p> <p>For those that wish to develop or enhance AI frameworks and compilers to leverage the Integrated Accelerator for AI, a lower level SDK is needed. To facilitate this, IBM has created the zDNN library. IBM zDNN is the IBM Z Deep Neural Network library, which features C apis that can simplify use of the z16 accelerator.</p> <p>Details and examples can be found in the IBM zDNN github.</p> <p>Note that zDNN library is distributed in z/OS 2.4 and above, as well as on RHEL, Ubuntu, SUSE at various levels. </p>"},{"location":"help/","title":"Getting help","text":""},{"location":"help/#resources-and-contacts","title":"Resources and Contacts","text":"<p>The path to getting started with AI on IBM zSystems and LinuxONE can vary based on the use case and goal that you have.</p> <p>In addition to this page, the following resources should be helpful:</p> <ul> <li>Journey to AI on IBM Z and LinuxONE content solution</li> <li>AI on IBM Z and LinuxONE Community</li> <li>Contact the IBM zSystems and LinuxONE AI core team</li> </ul>"},{"location":"help/#did-you-know-that-ibm-offers-an-ai-on-ibm-zsystems-and-linuxone-client-engineering-workshop-at-no-charge","title":"Did you know that IBM offers an AI on IBM zSystems and LinuxONE Client Engineering workshop at no charge?","text":"<p>This is a discovery workshop designed to help demystify the technology powering AI. It can be in-person or virtual, and tailored for your needs.</p> <p>It's targeted to IBM zSystem and LinuxONE customers who are interested in leveraging AI and analytic capabilities to gain new insights from their workloads and data.</p> <p>Contact ce4s@ibm.com for more information.</p>"},{"location":"infusing/","title":"Infusing AI into your IBM zSystem business applications","text":""},{"location":"infusing/#infusing-ai-into-ibm-z-and-linuxone-applications","title":"Infusing AI into IBM Z and LinuxONE applications","text":"<p>For detailed up to date information, see the Journey to AI on IBM Z and LinuxONE content solution</p> <p>See section \"Infusing AI into applications\" under \"Learn more\". </p>"},{"location":"onnxconv/","title":"ONNX model conversion","text":""},{"location":"onnxconv/#converting-models-to-the-onnx-format","title":"Converting models to the ONNX format","text":"<p>ONNX is the Open Neural Network eXchange. You can read more about it here and explore how it is leveraged by the IBM Z Deep Learning Compiler here.</p> <p>Converting or exporting trained deep learning models to the ONNX format is a requirement for leveraging the IBM Z Deep Learning Compiler, whether stand-alone or as part of Watson Machine Learning for z/OS. </p> <p>The approach in deep learning frameworks varies - for example:</p> <ul> <li>TensorFlow models must be converted using the open-source tensorflow-onnx package.</li> <li>PyTorch models can be exported directly to ONNX using PyTorch APIs.</li> </ul> <p>Information on exporting models from other frameworks can be found on the ONNX community page.</p>"},{"location":"onnxconv/#best-practices","title":"Best practices","text":"<ul> <li> <p>To avoid endian issues, we strongly recommend converting models to the ONNX format on the platform on which they were trained. (e.g., if a model was trained on an x86 environment, convert the model to ONNX on an x86 environment before transmitting to IBM Z or LinuxONE). </p> </li> <li> <p>For Deep Learning Compiler usage: to determine which ONNX opset to specify for model conversion, see the following references:</p> <ul> <li>NNPA supported opset level</li> <li>CPU supported opset level</li> </ul> </li> <li> <p>On z16 or LinuxONE 4 machines, we recommend using the highest opset level as specified under NNPA operator support. This will generally be the first statement in the file linked above; for example as of July 2023 \"Onnx-mlir currently supports ONNX operations targeting up to opset 18\".</p> </li> </ul>"},{"location":"onnxconv/#samples","title":"Samples","text":"<p>Additionally, IBM has published samples for both TensorFlow and ONNX, available here: https://github.com/IBM/ai-on-z-samples</p>"},{"location":"onnxdlc/","title":"ONNX and the IBM Deep Learning Compiler","text":""},{"location":"onnxdlc/#deploying-onnx-deep-learning-models-on-ibm-zsystems","title":"Deploying ONNX deep learning models on IBM zSystems","text":"<p>ONNX is the Open Neural Network eXchange. You can read more about it here.</p> <p>ONNX establishes a streamlined path to take a project from playground to production.  </p> <p>With ONNX, you can start a data science project using the frameworks and libraries of your choosing, including popular frameworks such as PyTorch and TensorFlow. The model can be developed and trained leveraging these frameworks on the training platform of your choice. Once the model is trained and ready to begin the deployment journey, you would export or convert it to the ONNX format. </p> <p>Tools such as Netron allow inspection and exploration of an ONNX model. When it comes to running the model, there are various back-ends that can be used to test and serve ONNX models. This includes model compilers such as the IBM Deep Learning Compiler (DLC), which is based on ONNX-MLIR. </p> <p>The ONNX-MLIR project provides compiler technology to transform a valid Open Neural Network Exchange (ONNX) graph into code that implements the graph with minimum runtime support. It implements the ONNX standard and is based on the underlying LLVM/MLIR compiler technology. </p> <p>The result of this compiler is a lightweight shared object library that has no dependencies on the framework or libraries that the model was developed and trained in. It can easily be used for inference from C++, Java or Python programs. </p>"},{"location":"onnxdlc/#ibm-z16-integrated-accelerator-for-ai","title":"IBM z16 Integrated Accelerator for AI","text":"<p>IBM Research enhanced the IBM Deep Learning Compiler (DLC) to target the IBM Integrated Accelerator for AI for a variety of ONNX primitives. This support has been contributed to ONNX-MLIR, which is the foundation for the IBM Deep Learning Compiler.</p>"},{"location":"onnxdlc/#getting-started-with-the-ibm-z-deep-learning-compiler","title":"Getting Started with the IBM Z Deep Learning Compiler","text":"<p>The best approach to getting started with ONNX models using the IBM Deep Learning Compiler will depend on the IBM zSystem operating system on which you plan to use the inference program. </p> <p>z/OS users can either choose a Watson Machine Learning for z/OS (WMLz) based approach or leverage Linux on Z options; in either case, z/OS Container Extensions will be required to utilize the IBM Z Deep Learning Compiler.</p> <p>There are two WMLz based options:</p> <ul> <li> <p>Watson Machine Learning for z/OS Online Scoring Community Edition (OSCE), which is freely available and excels at enabling rapid prototyping and proof of concept exercises. </p> <ul> <li>Simple install to z/OS Container Extensions (zCX).</li> <li>Enables you to upload your ONNX model then compile and deploy at the push of a button. </li> <li>Includes serving capability that exposes REST end points to call from an application.</li> <li>Available on the ibm.com WMLz page: 'Download trial code'.</li> </ul> </li> <li> <p>Watson Machine Learning for z/OS, which is a z/OS product that manages full model lifecycle and includes numerous features to improve performance for AI models and simplify deployment. </p> <ul> <li>Enables you to upload your ONNX model then compile and deploy at the push of a button. </li> <li>Supports server side mini-batching for ONNX/DLC model serving to get the best benefit out of the Integrated Accelerator for AI.</li> <li>Infuse AI into z/OS applications either through native CICS Cobol scoring services or by using model server REST endpoints.</li> </ul> </li> <li> <p>Additional resources: </p> <ul> <li>If you are interested in trying WMLz OSCE, here is a quick self-directed exercise that demonstrates how to call a ONNX model from a z/OS Java program: Demonstrating a z/OS application calling WMLz OSCE</li> </ul> </li> </ul> <p>Linux on Z and LinuxONE users can leverage the Deep Learning Compiler directly to create model programs that can be incorporated into serving environments or applications directly.</p> <ul> <li>Available through the IBM Z and LinuxONE Container Registry listed under zDLC.</li> <li>Command-line model compiler that produces a .so library with optional Java and Python wrappers.</li> <li>These model libraries can be leveraged either directly or through open-source AI inference servers such as Triton Inference Server. <ul> <li>Leveraging DLC with Triton Inference Server on LoZ</li> </ul> </li> <li>Additional samples: <ul> <li>Documentation and samples, including C++, Java, and Python clients</li> </ul> </li> </ul> <p>Read our blogs on ONNX for more information:  - IBM Z and the Open Neural Network Exchange  - Leveraging ONNX models on IBM zSystems and LinuxONE  - Announcing ONNX-MLIR/IBM Deep Learning Compiler for Linux on Z and LinuxONE</p>"},{"location":"opensource/","title":"Obtaining open-source packages","text":""},{"location":"opensource/#obtaining-open-source-ai-packages-on-ibm-z-and-linuxone","title":"Obtaining open source AI packages on IBM Z and LinuxONE","text":"<p>You can obtain open source AI packages using many of the methods you are familiar with.  </p> <p>Packages can be installed using Linux packages managers, PyPI, Anaconda, or of course built from source where necessary.</p> <p>Resources: </p> <ul> <li>Anaconda for s390x</li> <li>IBM Z and LinuxONE Container Registry</li> </ul> <p>Additional guidance on building specific packages for s390x can be found on the Linux on Z ecosystem repository</p> <p>If you need assistance with specific other packages, contact us. </p>"},{"location":"resources/","title":"Need access to a IBM Z or LinuxONE Environment?","text":""},{"location":"resources/#getting-access-to-ibm-z-and-linuxone-environments","title":"Getting access to IBM Z and LinuxONE environments.","text":"<p>Various Linux on Z VM and CI enviroment resources can be found here: IBM developer blog on resources</p> <p>IBM z16 environments are not available in the above resources just yet.  Reach out to us if you require a trial z16 environment (or have other needs not addressed above) at aionz@us.ibm.com</p>"},{"location":"snapml/","title":"IBM Snap Machine Learning (Snap ML)","text":""},{"location":"snapml/#traditional-machine-learning-with-ibm-snap-ml","title":"Traditional Machine Learning with IBM Snap ML","text":"<p>Snap ML is a library that provides high speed training and inference of popular machine learning models. You can read more about it here.</p> <p>Standard machine learning models power most of today's machine learning applications in business and are very popular among practitioners as well. Snap ML has been designed to address some of the biggest challenges that companies and practitioners face when applying machine learning to real use cases.</p> <p>Snap ML is a library for accelerating the training and inference of popular Machine Learning (ML) models:</p> <ul> <li>Provides high-performance implementations of:</li> <li>Generalized Linear Models</li> <li>Tree-based Models</li> <li>Gradient Boosting Machines</li> </ul> <p>Addresses ML needs of Data Scientists by being:</p> <ul> <li>Fast</li> <li>Resource-efficient</li> <li>Accurate</li> <li>Scalable to TB-scale datasets</li> </ul> <p>Snap ML:</p> <ul> <li>Is developed &amp; maintained by IBM Research. </li> <li>Is fully compatible with the scikit-learn Python API.</li> <li>Supports accelerated scoring of scikit-learn, XGBoost and LightGBM trained models when exported or converted to: PMML, JSON, ONNX.</li> </ul> <p>In addition to being available through PyPI, Snap ML is an available python framework in IBM Cloud Pak for Data. </p>"},{"location":"snapml/#z16-integrated-accelerator-for-ai","title":"z16 Integrated Accelerator for AI","text":"<p>Starting with Snap ML version 1.9.0, Snap ML can utilize the IBM Integrated Accelerator for AI. </p> <p>Integrated AI Accelerator exploitation can be enabled at model import time for:</p> <ul> <li>Random Forest</li> <li>Extra Trees</li> <li>Gradient Boosting Machines</li> </ul>"},{"location":"snapml/#getting-started-with-the-ibm-snap-ml","title":"Getting Started with the IBM Snap ML","text":"<p>Snap ML is available for IBM LinuxONE and Linux on Z environments, including z/OS container extensions. </p> <p>Linux on zSystems package available via PyPI: <pre><code>pip install snapml \n</code></pre> - This enables install into a python environment through standard mechanisms, at no charge. </p> <p>Snap ML is an available python framework in IBM Cloud Pak for Data.  </p> <ul> <li>Click here for official documentation</li> <li>Click here for examples using Snap ML</li> <li>Leveraging Snap ML with Triton Inference Server on LoZ</li> <li>Example using Snap ML with BentoML Serving</li> </ul>"},{"location":"snapml/#notes","title":"Notes:","text":"<ul> <li>Starting With Snap ML 1.9.1, SnapML-trained tree-based models (RF, ET and GB) can be exported to PMML.</li> </ul>"},{"location":"tensorflow/","title":"TensorFlow","text":""},{"location":"tensorflow/#tensorflow-on-ibm-zsystems-and-linuxone","title":"TensorFlow on IBM zSystems and LinuxONE","text":"<p>TensorFlow is a open source machine learning framework. It has a comphrensive set of tools that enable model development, training and inference. It also features a rich, robust ecosystem. </p> <p>TensorFlow can be used on IBM zSystems and LinuxONE on Linux environments - including z/OS Container Extensions.</p> <p>With TensorFlow Servng, you can expose REST and GRPC endpoints for model inference requests. This supports high throughput, low latency inference serving.</p> <p>On IBM zSystems and LinuxONE, TensorFlow is built to exploit the vector architecture for training and inference operations. On IBM z16 hardware, TensorFlow can leverage new inference acceleration capabilities. Read more below!</p>"},{"location":"tensorflow/#z16-integrated-accelerator-for-ai","title":"z16 Integrated Accelerator for AI","text":"<p>On Feb 8th 2023, IBM released a library called IBM-zDNN-Plugin on the Python Package Index (PyPI). </p> <p>The ibm-zdnn-plugin is a device plugin for TensorFlow that leverages the IBM z Deep Neural Network (zDNN) library for accelerated inferencing. On IBM\u00ae z16\u2122 hardware (running Linux on IBM Z or IBM\u00ae z/OS\u00ae Container Extensions (IBM zCX)), TensorFlow core 2.9 or later can leverage new inference acceleration capabilities by transparently targeting the IBM Integrated Accelerator for AI through the IBM-zDNN-Plugin.</p> <p>ibm-zdnn-plugin follows the TensorFlow PluggableDevice architecture, which provides a plug-in mechanism that allows devices to be registered in TensorFlow without changing the TensorFlow code. This capability allows TensorFlow to target the z16 accelerator seamlessly and transparently for several compute intensive operations.</p> <p>Read more about this support here</p>"},{"location":"tensorflow/#getting-started-with-tensorflow-on-ibm-zsystems-and-linuxone","title":"Getting Started with TensorFlow on IBM zSystems and LinuxONE","text":"<p>The recommended path for obtaining TensorFlow is to download a prebuilt container image from the IBM Z and LinuxONE Container Registry.</p> <p>The following images are available:</p> <ul> <li>TensorFlow Core (CPU)</li> <li>TensorFlow Serving (CPU)</li> </ul> <p>If you are interested in trying TensorFlow out, here is a quick self-directed exercise that demonstrates how to call a TensorFlow model from a z/OS Java program: TensorFlow and zCX interaction.</p> <p>Note that although this lab highlights TensorFlow on zCX, the image can just as easily be deployed to a Linux LPAR or VM using these steps.</p>"},{"location":"terminology/","title":"Terminology","text":""},{"location":"terminology/#terminology-and-technology-relationships","title":"Terminology and technology relationships","text":"<p>This page is focused primarily on IBM technologies and terminology. General open source and AI terminology can be found elsewhere on the net. </p> <p>Where applicable, for links see the sidebar.</p> <ul> <li> <p>IBM Z Deep Learning Compiler is an ONNX model compiler based on ONNX-MLIR. When compiling for IBM z16, it uses IBM zDNN APIs for ONNX operators that the Integrated Accelerator for AI supports. </p> </li> <li> <p>IBM Z Integrated Accelerator for AI is an on-chip AI inference accelerator that optimizes and acclerates complex AI operations beyond just matrix multiplication. It is invoked through the Neural Network Processing Assist (NNPA) instruction.</p> </li> <li> <p>NNPA (Neural Network Processing Assist) is a new architected instruction with the IBM z16 which is used to execute work on the IBM Integrated Accelerator for AI. Framework and compiler developers would typically use IBM zDNN library instead of attempting to directly code the NNPA instruction. Note that this is not something end users need to worry about - frameworks and compilers like the IBM Deep Learning Compiler (ONNX-MLIR), Snap ML, TensorFlow will handle this for you (at the right software levels!).</p> </li> <li> <p>IBM Telum is the zArchitecture chip that is featured in the IBM z16. IBM Telum includes an on-chip inference accelerator, known as the IBM Integrated Accelerator for AI.</p> </li> <li> <p>Watson Machine Learning for z/OS is a full lifecycle AI solution that features the ability to deploy AI models directly to z/OS for infusion into z/OS applications.</p> </li> <li> <p>IBM z16 is IBM's latest zSystem (mainframe), featuring the IBM Telum chip and the Integrated Accelerator for AI. </p> </li> <li> <p>IBM zDNN is IBM's open source API library for utilizing the IBM Integrated Accelerator for AI. It provides C APIs that greatly simplify use of the accelerator, including 'helper' functions. zDNN invokes the NNPA instruction on behalf of the caller to drive the accelerator.</p> </li> </ul>"},{"location":"z16Accel/","title":"Leveraging the IBM z16 Integrated Accelerator for AI","text":""},{"location":"z16Accel/#leveraging-the-ibm-integrated-accelerator-for-ai","title":"Leveraging the IBM Integrated Accelerator for AI","text":"<p>The IBM Integrated Accelerator for AI is an on-chip AI accelerator available on the IBM Telum chip that is part of IBM z16 and LinuxONE 4 servers. It is designed to enable high throughput, low latency inference for deep learning and machine learning. </p> <p>With IBM z16 and the Integrated Accelerator for AI, you can build and train your models on any platform - including IBM zSystems and LinuxONE. When you are ready to deploy your assets, they will receive transparent acceleration and optimization on IBM zSystems, and will leverage the best available acceleration for the model type.</p> <p>The IBM Integrated Accelerator for AI is more than just a matrix multiply accelerator - it provides optimization and acceleration for a wide set of complex functions commonly found in deep learning and machine learning models. This enables a broader set of functions to be accelerated on the chip.</p> <p>As of IBM z16, the following operations are supported on the accelerator:</p> <pre><code>LSTM Activation\nGRU Activation\nFused Matrix Multiply, Bias op\nFused Matrix Multiply (w/ broadcast)\nBatch Normalization\nFused Convolution, Bias Add, Relu\nMax Pool 2D\nAverage Pool 2D\nSoftmax\nRelu\nTanh\nSigmoid\nAdd\nSubtract\nMultiply\nDivide\nMin\nMax\nLog\n</code></pre> <p>These allow supporting frameworks to target a significantly larger set of operations to the Integrated Accelerator for AI. </p>"},{"location":"z16Accel/#using-the-integrated-accelerator-for-ai","title":"Using the Integrated Accelerator for AI","text":"<p>Depending on your model type, there are a few essential approaches to leveraging the Integrated Accelerator for AI. These capabilities are all available in various IBM product offerings as well as through no-cost channels (such as the IBM Z Container Image Repository). </p> <p>For deep learning models, such as those created in PyTorch or TensorFlow:</p> <ul> <li>ONNX deep learning models, when compiled using the IBM Z Deep Learning Compiler (onnx-mlir). <ul> <li>Note that Pytorch, TensorFlow, Apache MXNet and other model types can be easily converted to ONNX.</li> </ul> </li> <li>TensorFlow<ul> <li>By leveraging ibm-zdnn-plugin, which is a device plug-in for TensorFlow that allows TensorFlow to seamlessly utilize the Integrated Accelerator for AI.</li> </ul> </li> </ul> <p>For machine learning models, such as those created in sci-kit learn, XGBoost, or lightGBM:</p> <ul> <li>IBM Snap ML, a machine learning framework that provides optimized training and inference.<ul> <li>Tree based models such as Random Forest and Boosting Machine are accelerated using the Integrated Accelerator for AI.</li> <li>IBM Snap ML provides: <ul> <li>Seamless acceleration of sci-kit learn applications.</li> <li>Ability to execute lightGBM and XGBoost trained models when converted to JSON, PMML, or ONNX.</li> </ul> </li> </ul> </li> </ul> <p>For those interested in enhancing frameworks or compilers to use the Integrated Accelerator for AI:</p> <ul> <li>IBM zDNN<ul> <li>This is the accelerator development library, which is intended for use by those interested in enhancing frameworks or compilers to use the accelerator.  </li> </ul> </li> </ul> <p>For further details, use the navigation bar on this page to select a 'Featured Frameworks and Technologies' choice. </p> <p>Each of these are available as standalone packages, free of charge, or embedded within IBM products such as Watson Machine Learning for z/OS and Cloud Pak for Data. </p> <p>Further reading:</p> <ul> <li>IBM Telum announcement</li> </ul>"},{"location":"ai-on-z-containers/","title":"Index","text":""},{"location":"ai-on-z-containers/#ai-on-z-containers","title":"ai-on-z-containers","text":""},{"location":"ai-on-z-containers/#scope","title":"Scope","text":"<p>The purpose of this project is to provide container build files for AI software that can be utilized in s390x  environments.</p> <p>These container files (i.e., dockerfiles or containerfiles) are provided as examples that can be used directly  or built upon. They build open-source based (not proprietary) images. </p>"},{"location":"ai-on-z-containers/#usage","title":"Usage","text":"<p>These build files commonly rely on base images from the IBM Z and LinuxONE Container Image Registry (ICR) .  This will require free basic authentication. Details can be found at the ICR link above.</p> <p>Additionally, note that numerous pre-built s390x images are available in ICR.</p>"},{"location":"ai-on-z-containers/#content","title":"Content","text":"Folder(topic) Description nlp-spaCy spaCy library for natural language processing use cases"},{"location":"ai-on-z-containers/#license","title":"License","text":"<p>If you would like to see the detailed LICENSE click here.</p> <pre><code>#\n# Copyright 2020- IBM Inc. All rights reserved\n# SPDX-License-Identifier: Apache2.0\n#\n</code></pre>"},{"location":"ai-on-z-containers/CONTRIBUTING/","title":"CONTRIBUTING","text":""},{"location":"ai-on-z-containers/CONTRIBUTING/#contributing-in-general","title":"Contributing In General","text":"<p>Our project welcomes external contributions. If you have an itch, please feel free to scratch it.</p> <p>To contribute code or documentation, please submit a FIXME pull request.</p> <p>A good way to familiarize yourself with the codebase and contribution process is to look for and tackle low-hanging fruit in the FIXME issue tracker. Before embarking on a more ambitious contribution, please quickly get in touch with us.</p> <p>Note: We appreciate your effort, and want to avoid a situation where a contribution requires extensive rework (by you or by us), sits in backlog for a long time, or cannot be accepted at all!</p>"},{"location":"ai-on-z-containers/CONTRIBUTING/#proposing-new-features","title":"Proposing new features","text":"<p>If you would like to implement a new feature, please FIXME raise an issue before sending a pull request so the feature can be discussed. This is to avoid you wasting your valuable time working on a feature that the project developers are not interested in accepting into the code base.</p>"},{"location":"ai-on-z-containers/CONTRIBUTING/#fixing-bugs","title":"Fixing bugs","text":"<p>If you would like to fix a bug, please FIXME raise an issue before sending a pull request so it can be tracked.</p>"},{"location":"ai-on-z-containers/CONTRIBUTING/#merge-approval","title":"Merge approval","text":"<p>The project maintainers use LGTM (Looks Good To Me) in comments on the code review to indicate acceptance. A change requires LGTMs from two of the maintainers of each component affected.</p> <p>For a list of the maintainers, see the MAINTAINERS.md page.</p>"},{"location":"ai-on-z-containers/CONTRIBUTING/#legal","title":"Legal","text":"<p>Each source file must include a license header for the Apache Software License 2.0. Using the SPDX format is the simplest approach. e.g.</p> <pre><code>/*\nCopyright &lt;holder&gt; All Rights Reserved.\n\nSPDX-License-Identifier: Apache-2.0\n*/\n</code></pre> <p>We have tried to make it as easy as possible to make contributions. This applies to how we handle the legal aspects of contribution. We use the same approach - the Developer's Certificate of Origin 1.1 (DCO) - that the Linux\u00ae Kernel community uses to manage code contributions.</p> <p>We simply ask that when submitting a patch for review, the developer must include a sign-off statement in the commit message.</p> <p>Here is an example Signed-off-by line, which indicates that the submitter accepts the DCO:</p> <pre><code>Signed-off-by: John Doe &lt;john.doe@example.com&gt;\n</code></pre> <p>You can include this automatically when you commit a change to your local git repository using the following command:</p> <pre><code>git commit -s\n</code></pre>"},{"location":"ai-on-z-containers/CONTRIBUTING/#communication","title":"Communication","text":"<p>FIXME Please feel free to connect with us on our Slack channel.</p>"},{"location":"ai-on-z-containers/CONTRIBUTING/#setup","title":"Setup","text":"<p>FIXME Please add any special setup instructions for your project to help the developer become productive quickly.</p>"},{"location":"ai-on-z-containers/CONTRIBUTING/#testing","title":"Testing","text":"<p>FIXME Please provide information that helps the developer test any changes they make before submitting.</p>"},{"location":"ai-on-z-containers/CONTRIBUTING/#coding-style-guidelines","title":"Coding style guidelines","text":"<p>FIXME Optional, but recommended: please share any specific style guidelines you might have for your project.</p>"},{"location":"ai-on-z-containers/MAINTAINERS/","title":"MAINTAINERS","text":"<p>Christopher Ferris - chrisfer@us.ibm.com</p>"},{"location":"ai-on-z-containers/nlp-spaCy/","title":"Index","text":""},{"location":"ai-on-z-containers/nlp-spaCy/#spacy-a-natural-language-processing-library","title":"spaCy, a natural language processing library.","text":""},{"location":"ai-on-z-containers/nlp-spaCy/#overview","title":"Overview","text":"<p>spaCy.io</p> <p>spaCy github</p> <p>from the spaCy github project:</p> <p>spaCy is a library for advanced Natural Language Processing in Python and Cython. It's built on the very latest research, and was designed from day one to be used in real products.</p> <p>spaCy comes with pretrained pipelines and currently supports tokenization and training for 60+ languages. It features state-of-the-art speed and neural network models for tagging, parsing, named entity recognition, text classification and more, multi-task learning with pretrained transformers like BERT, as well as a production-ready training system and easy model packaging, deployment and workflow management. spaCy is commercial open-source software, released under the MIT license.</p>"},{"location":"ai-on-z-containers/nlp-spaCy/#usage","title":"Usage","text":"<p>This image can be built using the podman or docker build command.  e.g., <code>docker build -t 'spacy_s390x' .</code> Note that this docker files relies on base images from the IBM Z and LinuxONE Container Image Registry (ICR) . </p> <p>This build file includes jupyter and an example notebook to demonstrate basic syntax analysis with spaCy. </p> <p>Once this image is built, you can start a container using a command like this: <code>docker run -d --rm -p 8571:8888 &lt;image_id&gt;</code></p> <p>This will start a container which exposing jupyter port 8888 on host system port 8571.  If you specify -d (as above) you will need to display the jupyter token; this can be found by issuing <code>docker logs &lt;container_id&gt;</code> You can then direct your web browser to <code>&lt;host_ip_addr&gt;:&lt;exposed_port&gt;/?token=&lt;jupyter_token&gt;</code></p>"},{"location":"ai-on-z-fraud-detection/","title":"Index","text":""},{"location":"ai-on-z-fraud-detection/#scope","title":"Scope","text":"<p>This repository provides TensorFlow source code for building and training credit card fraud models using an LSTM and a GRU.</p>"},{"location":"ai-on-z-fraud-detection/#summary","title":"Summary","text":"<p>The models included in this repository are multi-layer LSTM or GRU models that analyze time series data to predict whether a credit card transaction is fraudulent.</p> <p>The models consist of a recurrent neural network (RNN) with 2 layers of long short-term memory (LSTM) or gated recurrent unit (GRU), 200 units in each layer, followed by a dense layer.  There is one output, which is Fraud/Non-fraud.  A sequence of 7 transactions is used as the input to model. </p> <p>In a transactional environment such as z/OS CICS, new data is generated from card terminal transactions.  The transaction is received by a z/OS application that then must process it.  As part of this processing, validation occurs.  This can include the use of AI to provide insight on whether the transaction is potentially fraudulent.</p> <p>The TensorFlow saved models were converted to the ONNX format using the tf2onnx 1.10.0 library and are also included in this repo.  The models were converted using the following template: <pre><code>import tf2onnx\nspec = (tf.TensorSpec((7, 16, 220), tf.float32, name=\"input\"),)\noutput_path = new_model.name + \".onnx\"\nonnx_model = tf2onnx.convert.from_keras(new_model, spec, output_path=output_path)\n</code></pre></p>"},{"location":"ai-on-z-fraud-detection/#environment","title":"Environment:","text":"<ul> <li>s390x</li> <li>python version 3.6.9</li> <li>pandas version 1.0.1</li> <li>numpy version 1.16.2</li> <li>scikit-learn version 0.22.1</li> <li>sklearn-pandas version 1.8.0</li> <li>TensorFlow version 2.1.0</li> </ul>"},{"location":"ai-on-z-fraud-detection/#the-dataset-used-in-this-repo-can-be-found-here","title":"The dataset used in this repo can be found here:","text":"<p>https://github.com/IBM/TabFormer/tree/main/data/credit_card</p>"},{"location":"ai-on-z-fraud-detection/#license","title":"License","text":"<p>If you would like to see the detailed LICENSE click here.</p>"},{"location":"ai-on-z-samples/","title":"Index","text":""},{"location":"ai-on-z-samples/#ai-on-z-samples","title":"ai-on-z-samples","text":""},{"location":"ai-on-z-samples/#scope","title":"Scope","text":"<p>This repository contains small, useful examples that serve to demonstrate some of the interesting  technologies available for use on IBM Z and LinuxONE systems. </p>"},{"location":"ai-on-z-samples/#samples-in-this-project","title":"Samples in this project:","text":"<ul> <li>TensorFlow Serving on zCX and z/OS simple app example.</li> <li>ONNX model export and conversion examples</li> </ul>"},{"location":"ai-on-z-samples/#notes","title":"Notes","text":"<p>If you have any questions or issues you can create a new [issue here][issues].</p> <p>If you have created a sample that you would like to share, please do so - pull requests are very welcome!  Ideally create a topic branch for every contribution or change you would like to suggest.  For example:</p> <ol> <li>Fork the repo</li> <li>Create your feature branch (<code>git checkout -b my-new-feature</code>)</li> <li>Commit your changes (<code>git commit -am 'Added some feature'</code>)</li> <li>Push to the branch (<code>git push origin my-new-feature</code>)</li> <li>Create new Pull Request</li> </ol>"},{"location":"ai-on-z-samples/#license","title":"License","text":"<p>If you would like to see the detailed LICENSE click here.</p> <pre><code>#\n# Copyright 2020- IBM Inc. All rights reserved\n# SPDX-License-Identifier: Apache2.0\n#\n</code></pre>"},{"location":"ai-on-z-samples/CONTRIBUTING/","title":"CONTRIBUTING","text":""},{"location":"ai-on-z-samples/CONTRIBUTING/#contributing-in-general","title":"Contributing In General","text":"<p>Our project welcomes external contributions. If you have an itch, please feel free to scratch it.</p> <p>To contribute code or documentation, please submit a pull request.</p> <p>A good way to familiarize yourself with the codebase and contribution process is to look for and tackle low-hanging fruit in the issue tracker.</p> <pre><code>/*\nCopyright &lt;holder&gt; All Rights Reserved.\n\nSPDX-License-Identifier: Apache-2.0\n*/\n</code></pre>"},{"location":"ai-on-z-samples/MAINTAINERS/","title":"MAINTAINERS","text":"<p>Andrew M. Sica - andrewsi@us.ibm.com Steve Lafalce - slafalce@us.ibm.com</p>"},{"location":"ai-on-z-samples/onnx-conversion/","title":"Exporting or converting a model to the ONNX format","text":"<p>This project contains some simple jupyter notebook examples demonstrating ONNX model conversion. This includes: - Exporting a simple model from Pytorch to ONNX format. - Converting a tensorflow model to ONNX, using tensorflow-onnx.</p> <p>These examples will require you install needed packages. This is not done as part of the notebook. </p> <p>There are numerous additional examples and guidance available, not only for Pytorch and TensorFlow, but for other frameworks as well.</p> <p>This includes: - Building, exporting or converting a model here - tensorflow-onnx examples - pytorch guidance and examples</p> <p>On IBM Z and LinuxONE, you can run these models using ONNX-MLIR. For z/OS users, we recommend you try Watson Machine Learning for z/OS Trial edition, available here.</p>"},{"location":"ai-on-z-samples/tf-zcx-zos/","title":"Demonstrating interaction between z/OS and TensorFlow Serving","text":"<p>This project intends to demonstrate a call to TensorFlow Serving using REST API from a simple z/OS Java app.  The purpose is to create a simple and easily deployable scenario that can be used on z/OS to understand serving concepts.</p> <p>This model performns a matrix multiplication of a [1,5] input tensor by a [5,1] weights tensor, where all weights are defined with a value of 1. This results in an output tensor shape of [1,1].</p> <p>For example, with this model an input tensor of [[1,2,3,4,5]] is multiplied by a weights tensor of [[1],[1],[1],[1],[1]],  resulting in a value of [[15.]]</p> <p>Note that since this project is intended for deployment to z/OS, we are avoiding managing dependecies through sub-moduling or Maven/Ant. The intent is to quickly try this project out without installing additional software. Required Jar files can be pulled from the references below.</p>"},{"location":"ai-on-z-samples/tf-zcx-zos/#deploying-tensorflow-serving-on-zos-container-extensions","title":"Deploying TensorFlow Serving on z/OS Container Extensions","text":"<ul> <li>TensorFlow Serving can be obtained from the IBM Container Image Repository or built from source for Linux on Z</li> <li>IBM Container Image Repository</li> <li>Source</li> <li> <p>Details on the TFServing API can be found here: https://www.tensorflow.org/tfx/serving/api_rest</p> </li> <li> <p>To deploy the example model, you can follow this procedure:</p> </li> <li>SFTP the TensorFlow saved model to zCX. This should be the model folder and all subfolders.<ul> <li>The saved model can be found in the model subdirectory of this project.</li> <li>The notebook used to create the model is simplemm.ipynb</li> </ul> </li> <li>Create a new docker volume.<ul> <li>e.g., <code>docker volume create tfmodels</code></li> <li>tfmodels is the volume name we create to use in subsequent steps</li> </ul> </li> <li>Copy the model directory into the docker volume. <ul> <li>One approach is to create a simple container using the volume to allow a docker cp:<ul> <li><code>docker container create --name tfsimple -v tfmodels:/models simple_image</code></li> <li><code>docker cp &lt;host_model_dir&gt; tfsimple:/models</code><ul> <li>tfsimple is the container name we create to facilitate the copy via docker CP. </li> <li>simple_image can be any base image, and it can be deleted after this copy.</li> <li>models is a directory we choose to copy the model into. </li> </ul> </li> </ul> </li> </ul> </li> <li>Run the TFServing image:          - <code>docker run -d --rm -p 8507:8501 -v tfmodels:/models -e MODEL_NAME=&lt;model_name&gt; &lt;image id&gt;</code>             - 8501 is the default TFServing REST port. Here it is mapped to zCX port 8507.              - model_name is the TensorFlow model name; this is commonly the directory name that holds the saved_model.pb file</li> </ul>"},{"location":"ai-on-z-samples/tf-zcx-zos/#updating-and-deploying-the-zos-application","title":"Updating and deploying the z/OS application","text":"<ul> <li>First, deploy the project to your host system. This program is intended for Unix environments.</li> <li>Suggestion on how to get github projects to z/OS can be found here: https://github.com/IBM/IBM-Z-zOS</li> <li>The following Jar files must be in the project root directory;</li> <li>Apache Commons Logging: commons-logging-1.1.3.jar</li> <li>Apache HttpClient: httpclient-4.5.13.jar</li> <li>Apache Httpcore: httpcore-4.4.14.jar</li> <li>Json Processing API javax.json-1.0.jar</li> <li>We suggest using SFTP to transmit the jars to the z/OS environment.</li> <li>Note: If different versions are used, update the Makefile to reference the correect version.</li> <li>run <code>make</code> to build compile the .java files</li> <li>issue the following command to try a TensorFlow Serving request:   </li> <li><code>make run HOSTIP=tf-serve-ip PORT=tf-serv-port MODEL_DIR=model-dir PAYLOAD=input-tensor</code><ul> <li>tf-serve-ip is the IP address of the server or instance hosting TensorFlow Serving</li> <li>tf-serv-port is the TF Serving REST port</li> <li>model-dir is the model path, which should typically be /v1/models/simplemm for the sample model.</li> <li>input-tensor consists of 5 comma separated decimal values. </li> </ul> </li> </ul> <p>For example, if we mapped the TFServing REST port to 8507, we would use something like this (changing the IP address     to one in use by zCX):       <code>make run HOSTIP=127.0.0.1 PORT=8507 MODEL_DIR=/v1/models/simplemm PAYLOAD=1.0,2.0,3.0,4.0,5.0</code></p> <p>In addition to verbose messages, the result for test would show:       {          \"predictions\": [[15.0]          ]       }</p>"},{"location":"zDNN/","title":"zDNN API Reference","text":""},{"location":"zDNN/#contacts","title":"Contacts","text":"<ul> <li>Nicholas Marion (nmarion@us.ibm.com)</li> <li>Andreas Krebbel (krebbel@linux.ibm.com)</li> </ul>"},{"location":"zDNN/#version","title":"Version","text":"<p>0.4.0</p>"},{"location":"zDNN/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Overview</li> <li>Environment</li> <li> <p>Common Data Types and Structs</p> </li> <li> <p>Version Information</p> </li> <li>zDNN zTensor<ul> <li>General zTensor Requirements</li> <li>Concatenated zTensor Requirements</li> </ul> </li> <li>zDNN Tensor Descriptors</li> <li>zDNN Data Layouts</li> <li>zDNN Data Formats</li> <li>zDNN Data Types</li> <li> <p>zDNN Statuses</p> </li> <li> <p>Runtime Environment Variables</p> </li> <li> <p>API Reference</p> </li> <li> <p>Support Functions</p> </li> <li>Data Transformation</li> <li> <p>Operations</p> <ul> <li>Element-wise</li> <li>Activation</li> <li>Normalization</li> <li>Matmul with Operation</li> <li>Matmul Broadcast with Operation</li> <li>LSTM</li> <li>GRU</li> <li>Average Pool 2D</li> <li>Max Pool 2D</li> <li>Convolution 2D</li> </ul> </li> <li> <p>Convenience Functions</p> </li> <li> <p>Usage Examples</p> </li> </ol>"},{"location":"zDNN/#overview","title":"Overview","text":"<p>Deep Learning Library - the deep learning library support (zDNN) is the SW enablement technology provided by IBM to meet the following requirements:</p> <ul> <li>Specialized-function-assist instructions are intended to provide performance   improvements for specific operations used in software libraries, utilities,   and operating system (OS) services. The facilities and instructions described   as specialized-function-assist instructions may be replaced or removed in the   future. As such, the IBM recommendation for these instructions is that a   software library or operating system function be used instead of directly   accessing the instructions. This is the function provided by zDNN.</li> <li>zAIU has very complex data layout requirements; these requirements arrange the   tensor to enhance the performance characteristics of the operations. zDNN will   format the tensor appropriately on behalf of the caller, and it will do so   using an optimized approach.</li> <li>For deep learning operations, zAIU requires the use of an internal data type   (DLFLOAT16). This is a 2-byte data type, similar in concept to Brain   float (BFLOAT); that is, it is an AI optimized format that is used to speed up   training and inference (from 4-byte formats) while minimizing the loss of   accuracy at inference time.</li> </ul> <p>The zDNN library will provide a set of APIs that an exploiter will utilize to drive the desired request. zDNN will be available on both z/OS and Linux on Z; the inclusion of Linux on Z provides particular benefit, as it will allow us to enable acceleration in frameworks for z/OS via z/OS Container Extensions (zCX).</p>"},{"location":"zDNN/#environment","title":"Environment","text":"<p>z/OS:</p> <ul> <li>Problem state</li> <li>AMODE64</li> <li>XPLINK</li> </ul>"},{"location":"zDNN/#alignment-requirements","title":"Alignment requirements","text":""},{"location":"zDNN/#aiu-op-limits","title":"AIU Op Limits","text":"<p>This implies a zDNN limitation as well at this point.</p> <ul> <li> <p>For all ops:</p> </li> <li> <p>Number of elements in any dimension must not exceed the value returned by     <code>zdnn_get_nnpa_max_dim_idx_size()</code></p> </li> <li>Total number of bytes required for storing a transformed tensor must not     exceed the value returned by <code>zdnn_get_nnpa_max_tensor_size()</code></li> </ul>"},{"location":"zDNN/#application-interfaces-for-zaiu-enterprise-neural-network-inference","title":"Application interfaces for zAIU Enterprise Neural Network Inference","text":""},{"location":"zDNN/#zdnn-general","title":"zDNN General","text":"<p>The zDNN deep learning library provides the standard IBM Z software interface to the zAIU. This IBM-provided C library provides a set of functions that handle the data transformation requirements of the AIU and provide wrapper functions for the NNPA instruction primitives.</p> <p>The zDNN functions use the following criteria to determine if zAIU can be used to accelerate a deep learning primitive:</p> <ul> <li>Neural Network Processing Assist (NNPA) facility indicator in the system STFLE   output.</li> <li>Output of the NNPA-QAF (Query Available Functions) request.</li> </ul>"},{"location":"zDNN/#using-zdnn","title":"Using zDNN","text":"<p>To use the IBM-provided zDNN C library for the NNPA instruction, follow these steps:</p> <ol> <li>Link or re-link applications to use the IBM-provided zDNN. The IBM-provided    zDNN is a library file in the z/OS UNIX System Services file system and can    be statically or dynamically linked into your applications. The paths for the    zDNN archive file and the zDNN header files are:</li> </ol> <p>z/OS (LE required): Path for 64-bit dynamic library files:</p> <ul> <li><code>/lib/libzdnn.so</code></li> <li><code>/lib/libzdnn.x</code></li> </ul> <p>Path for the zDNN header files:</p> <ul> <li><code>/usr/include/</code></li> </ul> <p>The XL C/C++ compiler and the z/OS Language Environment provide various environment variables to control processing, in addition to the variables provided by the zDNN library itself.</p> <ol> <li> <p>Use the environment variable <code>_CEE_RUNOPTS</code> to specify invocation Language    Environment runtime options. For more information about using the environment    variable <code>_CEE_RUNOPTS</code> and other C and LE variables, see z/OS XL C/C++    Programming Guide.</p> </li> <li> <p>For environment variables accepted by the zDNN library, see    Runtime Environment Variables.</p> </li> </ol> <p>Linux on Z:</p> <p>On Linux on Z we expect to ship source as well a package-installable library and header. The library installation will conform to the standards of the packaging method chosen.</p>"},{"location":"zDNN/#common-types-and-structs","title":"Common Types and Structs","text":"<p>Include Files: <code>zdnn.h</code></p>"},{"location":"zDNN/#version-information","title":"Version Information","text":"<p>Back to Table of Contents</p> <pre><code>#define ZDNN_VERSION \"0.4.0\"\n#define ZDNN_VERNUM 0x000400 // 0x[major][minor][patch]\n#define ZDNN_VER_MAJOR 0\n#define ZDNN_VER_MINOR 4\n#define ZDNN_VER_PATCH 0\n</code></pre> <ol> <li>zDNN major version (ZDNN_VER_MAJOR) will be incremented if any backwards    incompatible changes are introduced to the API. It may also include minor and    patch level changes. Patch and minor version will be reset to 0 when major    version is incremented.</li> <li>zDNN minor version (ZDNN_VER_MINOR) will be incremented if new, backwards    compatible functionalities are introduced to the API or if any API    functionalities are marked as deprecated. It may also include patch level    changes. Patch version will be reset to 0 when minor version is incremented.</li> <li>zDNN patch version (ZDNN_VER_PATCH) will be incremented if only backwards    compatible bug fixes are introduced. A bug fix being defined as an internal    change that fixes incorrect behavior.</li> </ol> <p>Functions for checking version incompatibility with the zDNN load library are provided and described in the Support Functions section.</p>"},{"location":"zDNN/#zdnn-ztensor","title":"zDNN zTensor","text":"<p>Back to Table of Contents</p> <pre><code>typedef struct zdnn_ztensor {\n  zdnn_tensor_desc\n      *pre_transformed_desc; // tensor's shape information before transformation\n  zdnn_tensor_desc *transformed_desc; // transformed tensor's shape information\n  uint64_t buffer_size;               // tensor size in bytes\n  void *buffer;                       // pointer to the tensor in memory\n  bool is_transformed; // indicator if data in buffer has been transformed\n  char reserved[31];   // not currently used, should contain zeros.\n} zdnn_ztensor;\n</code></pre>"},{"location":"zDNN/#general-ztensor-requirements","title":"General zTensor Requirements","text":"<p>Back to Table of Contents</p> <ul> <li><code>buffer</code> requirements:</li> <li>Calling zdnn_init_ztensor_with_malloc     automatically allocates and sets a valid <code>buffer</code> for a tensor.</li> <li><code>buffer</code> field must point to storage allocated of sufficient size to contain     the transformed tensor data described by the its <code>transformed_desc</code> field.<ul> <li>Calling zdnn_getsize_ztensor with the tensor's   <code>transformed_desc</code> returns the required size.</li> </ul> </li> <li>Start of <code>buffer</code> field must be 4k aligned.</li> <li><code>reserved</code> should contain zeros, otherwise the program may not operate   compatibly in the future.</li> <li>Calling zdnn_init_ztensor or     zdnn_init_ztensor_with_malloc will set     <code>reserved</code> to zeros.</li> </ul>"},{"location":"zDNN/#concatenated-ztensor-requirements","title":"Concatenated zTensor Requirements","text":"<p>Back to Table of Contents</p> <ul> <li>For use with weights/biases/hidden-weights/hidden-biases RNN-gates tensors.</li> <li>You must use   zdnn_generate_transformed_desc_concatenated   with the appropriate concatenation info</li> <li>Do not use <code>zdnn_generate_transformed_desc</code> with concatenated tensors</li> <li>The pre-transformed shape dimensions should not include the concatenation.</li> <li>Thus, the pre-transformed shape should be that of a single gate, not the     shape of the combined gates</li> <li>Afterward transform with zdnn_transform_ztensor as   normal</li> <li>Must follow general tensor requirements</li> </ul>"},{"location":"zDNN/#zdnn-tensor-descriptors","title":"zDNN Tensor Descriptors","text":"<p>Back to Table of Contents</p> <pre><code>typedef struct zdnn_tensor_desc {\n  zdnn_data_layouts layout; // data layout\n  zdnn_data_formats format; // internal use only\n  zdnn_data_types type;     // data type\n  uint32_t dim4;            // number of elements in outermost dimension\n  uint32_t dim3;            // ... outer dimension\n  uint32_t dim2;            // ... inner dimension\n  uint32_t dim1;            // number of elements in innermost dimension\n} zdnn_tensor_desc;\n</code></pre>"},{"location":"zDNN/#programming-notes","title":"Programming Notes","text":"<ul> <li>Helper methods   zdnn_init_pre_transformed_desc and   zdnn_generate_transformed_desc or   zdnn_generate_transformed_desc_concatenated   will set the correct dims based on the layout and format.</li> <li>The layout of the tensor descriptor affects the expected   order of the dims. For example:</li> <li>For tensors with less than 4 dimensions, unspecified dims:<ul> <li>In the pre_transformed_desc are ignored. For example a   ZDNN_3D expects values in dim4, dim3, and dim2.</li> <li>In the transformed_desc \"unused\" dims must be 1.</li> </ul> </li> <li>A ZDNN_NCHW expects dims such that dim4 = N, dim3 = H,     dim2 = W, dim1 = C</li> <li>A ZDNN_HWCK expects dims such that dim4 = W, dim3 = W,     dim2 = C, dim1 = K</li> <li>The format changes the expected dims order for   ZDNN_4D tensors layouts</li> <li>ZDNN_FORMAT_4DFEATURE expects dims such that dim4 = N,     dim3 = H, dim2 = W, dim1 = C</li> <li>ZDNN_FORMAT_4DKERNEL expects dims such that dim4 = H,     dim3 = W, dim2 = C, dim1 = K</li> </ul>"},{"location":"zDNN/#zdnn-data-layouts","title":"zDNN Data Layouts","text":"<p>Back to Table of Contents</p> <p>The following are layouts for zDNN ztensor descriptors. These indicate the number and order of dimensions to expect for the ztensor data.</p> <pre><code>typedef enum zdnn_data_layouts {\n  ZDNN_1D,          // 1d tensor\n  ZDNN_2D,          // 2d tensor\n  ZDNN_2DS,         // represents special 2D tensors required by LSTM/GRU\n  ZDNN_3D,          // 3d tensor\n  ZDNN_3DS,         // represents special 3D tensors required by\n                    // LSTM/GRU/Softmax/Matmul\n  ZDNN_ZRH,         // represents (update, reset, hidden) used by GRU\n  ZDNN_4D,          // 4d tensor\n  ZDNN_4DS,         // represents special 4D tensors required by LSTM/GRU output\n  ZDNN_NHWC,        // 4d feature tensor in NHWC\n  ZDNN_NCHW,        // 4d feature tensor in NCHW\n  ZDNN_FICO,        // represents (forget, input, cell, output) used by LSTM\n  ZDNN_HWCK,        // 4d kernel CNN tensor\n  ZDNN_BIDIR_ZRH,   // ZRH variant to work with bidirectional LSTM/GRU output\n  ZDNN_BIDIR_FICO  // FICO variant to work with bidirectional LSTM/GRU output\n} zdnn_data_layouts;\n</code></pre> <p>Some layouts also indicate special re-arrangement of the data during ztensor transformation.</p> <ul> <li><code>ZDNN_2DS</code> - The outermost dimension of the original shape is promoted to dim4   during transformation. For example, a shape of (a, b) becomes [a, 1, 1, b]   (dim4, dim3, dim2, dim1) in the <code>transformed_desc</code></li> <li><code>ZDNN_3DS</code> - The outermost dimension of the original shape is promoted to dim4   during transformation. For example, a shape of (a, b, c) becomes [a, 1, b, c]   (dim4, dim3, dim2, dim1) in the <code>transformed_desc</code></li> <li><code>ZDNN_4DS</code> - Arrangement for RNN output tensor</li> </ul> <p>The followings are set automatically in <code>transformed_desc</code> based on <code>info</code> when calling <code>zdnn_generate_transformed_desc_concatenated()</code>:</p> <ul> <li><code>ZDNN_ZRH/FICO</code> - During transformation, the RNN input gates data are   concatenated on the innermost dimension. Supported with   <code>pre_transformed_layout</code> of <code>ZDNN_2DS</code> or <code>ZDNN_3DS</code>.</li> <li><code>ZDNN_BIDIR_ZRH/FICO</code> - Similar to <code>ZDNN_ZRH/FICO</code>, used when:</li> <li>transforming RNN input weight gate data, and</li> <li>the input tensor for the current RNN layer is a bidirectional RNN output      from a previous RNN layer</li> </ul>"},{"location":"zDNN/#zdnn-data-formats","title":"zDNN Data Formats","text":"<p>Back to Table of Contents</p> <pre><code>typedef enum zdnn_data_formats {\n  ZDNN_FORMAT_4DFEATURE, // tensor in AIU data layout format 0\n  ZDNN_FORMAT_4DKERNEL, // tensor in AIU data layout format 1\n} zdnn_data_formats;\n</code></pre>"},{"location":"zDNN/#zdnn-data-types","title":"zDNN Data Types","text":"<p>Back to Table of Contents</p> <pre><code>typedef enum zdnn_data_types {\n  ZDNN_DLFLOAT16, // 16-bit deep learning format\n  BFLOAT, // Brain floating point format\n  FP16, // 16-bit IEEE-754 floating point format\n  FP32, // 32-bit IEEE-754 floating point format\n} zdnn_data_types;\n</code></pre>"},{"location":"zDNN/#zdnn-statuses","title":"zDNN Statuses","text":"<p>Back to Table of Contents</p> Mnemonic Constant Value Meaning ZDNN_OK 0x00000000 Success."},{"location":"zDNN/#warning-statuses","title":"Warning Statuses","text":"Mnemonic Constant Value Meaning ZDNN_ELEMENT_RANGE_VIOLATION 0x00020001 AIU operation resulted in data that was out of the normal range. <p>Note: ZDNN_ELEMENT_RANGE_VIOLATION indicates a range violation occurred for the AIU operation based on the data in the tensors. This usually indicates an overflow of the NNPA internal data type, but can also be associated with operation specific errors, such as \"divide by zero\". See the \"z/Architecture Principles of Operation\" for information about range violation on the operation that encountered the violation.</p>"},{"location":"zDNN/#general-failing-statuses","title":"General Failing Statuses","text":"Mnemonic Constant Value Meaning ZDNN_INVALID_SHAPE* 0x00040001 Invalid shape information in one (or more) of the input/output tensor(s). ZDNN_INVALID_LAYOUT 0x00040002 Invalid layout information in one (or more) of the input/output tensor(s). ZDNN_INVALID_TYPE* 0x00040003 Invalid type information in one (or more) of the input/output tensor(s). ZDNN_INVALID_FORMAT* 0x00040004 Invalid format information in one (or more) of the input/output tensor(s). ZDNN_INVALID_DIRECTION 0x00040005 Invalid RNN direction. ZDNN_INVALID_CONCAT_INFO 0x00040006 Invalid concatenation info. ZDNN_INVALID_STRIDE_PADDING* 0x00040007 Invalid padding type parameter for current strides. ZDNN_INVALID_STRIDES* 0x00040008 Invalid stride height or width parameter. ZDNN_MISALIGNED_PARMBLOCK* 0x00040009 NNPA parameter block is not on double word boundary. ZDNN_INVALID_CLIPPING_VALUE 0x0004000A Invalid clipping for the specified operation. ZDNN_ALLOCATION_FAILURE 0x00100001 Can not allocate storage. ZDNN_INVALID_BUFFER 0x00100002 Buffer address is NULL or not on 4K-byte boundary or insufficient buffer size. ZDNN_CONVERT_FAILURE 0x00100003 Floating point data conversion failure. ZDNN_INVALID_STATE 0x00100004 Invalid zTensor state. ZDNN_UNSUPPORTED_AIU_EXCEPTION 0x00100005 AIU operation returned an unexpected exception. <p>Note: *In certain scenarios, these statuses are returned only if ZDNN_ENABLE_PRECHECK is enabled. When not enabled, these scenarios will lead to abnormal program termination.</p>"},{"location":"zDNN/#hardware-statuses","title":"Hardware Statuses","text":"<p>The following statuses indicate issues returned from the hardware.</p> Mnemonic Constant Value Meaning ZDNN_UNSUPPORTED_PARMBLOCK 0x000C0001 NNPA parameter block format is not supported by the model. ZDNN_UNAVAILABLE_FUNCTION 0x000C0002 Specified NNPA function is not defined or installed on the machine. ZDNN_UNSUPPORTED_FORMAT 0x000C0010 Specified tensor data layout format is not supported. ZDNN_UNSUPPORTED_TYPE 0x000C0011 Specified tensor data type is not supported. ZDNN_EXCEEDS_MDIS 0x000C0012 Tensor dimension exceeds maximum dimension index size (MDIS). ZDNN_EXCEEDS_MTS 0x000C0013 Total number of bytes in tensor exceeds maximum tensor size. (MTS). ZDNN_MISALIGNED_TENSOR 0x000C0014 Tensor address is not on 4K-byte boundary. ZDNN_MISALIGNED_SAVEAREA 0x000C0015 Function specific save area address is not on 4K-byte boundary. <p>The meaning of the following hardware statuses vary based on operation. See the operation that returned the status for the specific meaning.</p> Mnemonic Constant Value Meaning ZDNN_FUNC_RC_F000 0x000CF000 Function specific response code (F000). ZDNN_FUNC_RC_F001 0x000CF001 Function specific response code (F001). ZDNN_FUNC_RC_F002 0x000CF002 Function specific response code (F002). ZDNN_FUNC_RC_F003 0x000CF003 Function specific response code (F003). ZDNN_FUNC_RC_F004 0x000CF004 Function specific response code (F004). ZDNN_FUNC_RC_F005 0x000CF005 Function specific response code (F005). ZDNN_FUNC_RC_F006 0x000CF006 Function specific response code (F006). ZDNN_FUNC_RC_F007 0x000CF007 Function specific response code (F007). ZDNN_FUNC_RC_F008 0x000CF008 Function specific response code (F008). ZDNN_FUNC_RC_F009 0x000CF009 Function specific response code (F009)."},{"location":"zDNN/#runtime-environment-variables","title":"Runtime Environment Variables","text":"<p>Back to Table of Contents</p> <ul> <li><code>ZDNN_ENABLE_PRECHECK</code>: true/false</li> <li>If set to <code>true</code>, tensor integrity prechecks are run before issuing NNPA     operations.</li> <li>Enabling precheck may impact performance.</li> <li>Enable to debug issues which cause hardware exceptions that otherwise would     result in abnormal program termination.</li> <li><code>ZDNN_STATUS_DIAG</code>: nnnnnnnn (decimal) or 0xnnnnnnnn (hexadecimal)</li> <li>Prints or produces diagnostic information whenever zDNN status code is equal     to the specified value. Only one status value can be specified.</li> </ul> <p>The following are only available when the zDNN library was built with <code>ZDNN_CONFIG_DEBUG</code> enabled.</p> <ul> <li><code>ZDNN_LOGLEVEL</code>: off/fatal/error/warn/info/debug/trace</li> <li>Sets logging facility's output level</li> <li><code>ZDNN_LOGMODULE</code>: module name(s)</li> <li>Produces log output only when the issuer's module name is in the list. You     may specify multiple module names by separating them with either commas or     spaces.</li> </ul>"},{"location":"zDNN/#programming-notes_1","title":"Programming Notes","text":"<ul> <li>Environment variables settings are checked during initial library load by   zdnn_init.</li> <li>To change environment variable settings afterward, zdnn_init   must be called again manually.</li> </ul>"},{"location":"zDNN/#api-reference","title":"API Reference","text":"<p>Back to Table of Contents</p> <ul> <li>Support Functions</li> <li>Data Transformation</li> <li>Operations</li> <li>Convenience Functions</li> </ul>"},{"location":"zDNN/#support-functions","title":"Support Functions","text":"<p>Back to Table of Contents</p> <ul> <li>Initialization</li> <li>Query</li> <li>Get Size</li> <li>Initialize pre-transformed tensor descriptor</li> <li>Generate transformed tensor descriptor</li> <li>Generate concatenated transformed tensor descriptor</li> <li>Initialize zTensor</li> <li>Initialize zTensor with memory allocate</li> <li>Reset zTensor</li> <li>Allocate memory for zTensor</li> <li>De-allocate memory for zTensor</li> <li>Retrieve status message of the status code</li> <li>Reshape zTensor</li> <li>Check if version is runnable</li> <li>Get maximum runnable version</li> </ul>"},{"location":"zDNN/#zdnn_init","title":"zdnn_init","text":""},{"location":"zDNN/#description","title":"Description","text":"<p>Initialize the zDNN library. This sends an NNPA_QAF to query the NNPA and loads the current environment variable settings.</p> <p>This needs to be invoked at least once if zDNN library is statically-linked. It is automatically invoked if zDNN library is dynamically loaded.</p>"},{"location":"zDNN/#format","title":"Format","text":"<pre><code>void zdnn_init();\n</code></pre>"},{"location":"zDNN/#parameters","title":"Parameters","text":"<p>None</p>"},{"location":"zDNN/#returns","title":"Returns","text":"<p>None</p>"},{"location":"zDNN/#zdnn_get_nnpa_max_dim_idx_size","title":"zdnn_get_nnpa_max_dim_idx_size","text":""},{"location":"zDNN/#description_1","title":"Description","text":"<p>Retrieve the maximum dimension index size value currently supported by the AIU from zDNN's internal memory.</p>"},{"location":"zDNN/#format_1","title":"Format","text":"<pre><code>uint32_t zdnn_get_nnpa_max_dim_idx_size();\n</code></pre>"},{"location":"zDNN/#parameters_1","title":"Parameters","text":"<p>None</p>"},{"location":"zDNN/#returns_1","title":"Returns","text":"<p>Maximum dimension index size supported by the AIU</p>"},{"location":"zDNN/#zdnn_get_nnpa_max_tensor_size","title":"zdnn_get_nnpa_max_tensor_size","text":""},{"location":"zDNN/#description_2","title":"Description","text":"<p>Retrieve the maximum tensor size value (number of bytes required for storing a transformed tensor) currently supported by the AIU from zDNN's internal memory.</p>"},{"location":"zDNN/#format_2","title":"Format","text":"<pre><code>uint64_t zdnn_get_nnpa_max_tensor_size();\n</code></pre>"},{"location":"zDNN/#parameters_2","title":"Parameters","text":"<p>None</p>"},{"location":"zDNN/#returns_2","title":"Returns","text":"<p>Maximum tensor size supported by the AIU</p>"},{"location":"zDNN/#zdnn_is_nnpa_installed","title":"zdnn_is_nnpa_installed","text":""},{"location":"zDNN/#description_3","title":"Description","text":"<p>Interrogates the hardware to determine if the NNPA and NNP-internal data type (DLFLOAT16) conversion instructions are installed.</p> <p>Use this function during application initialization to determine whether the AIU hardware is available.</p>"},{"location":"zDNN/#format_3","title":"Format","text":"<pre><code>bool zdnn_is_nnpa_installed();\n</code></pre>"},{"location":"zDNN/#parameters_3","title":"Parameters","text":"<ul> <li>None.</li> </ul>"},{"location":"zDNN/#returns_3","title":"Returns","text":"<p><code>true</code> if NNPA and zdnn conversion instructions are installed, <code>false</code> otherwise.</p>"},{"location":"zDNN/#zdnn_is_nnpa_function_installed","title":"zdnn_is_nnpa_function_installed","text":""},{"location":"zDNN/#description_4","title":"Description","text":"<p>Query, from zDNN internal memory, if requested NNPA functions are available.</p>"},{"location":"zDNN/#format_4","title":"Format","text":"<pre><code>bool zdnn_is_nnpa_function_installed(int count, ...);\n</code></pre>"},{"location":"zDNN/#parameters_4","title":"Parameters","text":"<ul> <li> <p><code>int count</code></p> </li> <li> <p>number of NNPA functions to check</p> </li> <li> <p><code>... (additional arguments)</code></p> </li> <li> <p>Function names separated by commas, e.g., NNPA_MUL, NNPA_MIN</p> </li> </ul> <pre><code>NNPA_QAF\nNNPA_ADD\nNNPA_SUB\nNNPA_MUL\nNNPA_DIV\nNNPA_MIN\nNNPA_MAX\nNNPA_LOG\nNNPA_EXP\nNNPA_RELU\nNNPA_TANH\nNNPA_SIGMOID\nNNPA_SOFTMAX\nNNPA_BATCHNORMALIZATION\nNNPA_MAXPOOL2D\nNNPA_AVGPOOL2D\nNNPA_LSTMACT\nNNPA_GRUACT\nNNPA_CONVOLUTION\nNNPA_MATMUL_OP\nNNPA_MATMUL_OP_BCAST23\n</code></pre>"},{"location":"zDNN/#returns_4","title":"Returns","text":"<p><code>true</code> if all queried formats are installed or if <code>count</code> is zero, <code>false</code> otherwise.</p>"},{"location":"zDNN/#zdnn_is_nnpa_parmblk_fmt_installed","title":"zdnn_is_nnpa_parmblk_fmt_installed","text":""},{"location":"zDNN/#description_5","title":"Description","text":"<p>Query, from zDNN internal memory, if requested parameter block formats are installed.</p>"},{"location":"zDNN/#format_5","title":"Format","text":"<pre><code>bool zdnn_is_nnpa_parmblk_fmt_installed(int count, ...);\n</code></pre>"},{"location":"zDNN/#parameters_5","title":"Parameters","text":"<ul> <li> <p><code>int count</code></p> </li> <li> <p>number of NNPA parameter block formats to check</p> </li> <li> <p><code>... (additional arguments)</code></p> </li> <li> <p>NNPA parameter block formats separated by commas</p> </li> </ul> <pre><code>NNPA_PARMBLKFORMAT_0\n</code></pre>"},{"location":"zDNN/#returns_5","title":"Returns","text":"<p><code>true</code> if all queried formats are installed or if <code>count</code> is zero, <code>false</code> otherwise.</p>"},{"location":"zDNN/#zdnn_is_nnpa_datatype_installed","title":"zdnn_is_nnpa_datatype_installed","text":""},{"location":"zDNN/#description_6","title":"Description","text":"<p>Query, from zDNN internal memory, if requested NNPA data type are installed.</p>"},{"location":"zDNN/#format_6","title":"Format","text":"<pre><code>bool zdnn_is_nnpa_datatype_installed(uint16_t types_bitmask);\n</code></pre>"},{"location":"zDNN/#parameters_6","title":"Parameters","text":"<ul> <li> <p><code>uint16_t types_bitmask</code></p> </li> <li> <p>OR'd type bitmasks as defined in zdnn_query_datatypes enum</p> </li> </ul> <pre><code>QUERY_DATATYPE_INTERNAL1\n</code></pre>"},{"location":"zDNN/#returns_6","title":"Returns","text":"<p><code>true</code> if all queried data types are installed, <code>false</code> otherwise.</p>"},{"location":"zDNN/#zdnn_is_nnpa_layout_fmt_installed","title":"zdnn_is_nnpa_layout_fmt_installed","text":""},{"location":"zDNN/#description_7","title":"Description","text":"<p>Query, from zDNN internal memory, if requested NNPA data layout format are installed.</p>"},{"location":"zDNN/#format_7","title":"Format","text":"<pre><code>bool zdnn_is_nnpa_layout_fmt_installed(uint32_t layout_bitmask);\n</code></pre>"},{"location":"zDNN/#parameters_7","title":"Parameters","text":"<ul> <li> <p><code>uint32_t layout_bitmask</code></p> </li> <li> <p>OR'd layout bitmasks as defined in zdnn_query_layoutfmts enum</p> </li> </ul> <pre><code>QUERY_LAYOUTFMT_4DFEATURE\nQUERY_LAYOUTFMT_4DKERNEL\n</code></pre>"},{"location":"zDNN/#returns_7","title":"Returns","text":"<p><code>true</code> if all queried data layouts are installed, <code>false</code> otherwise.</p>"},{"location":"zDNN/#zdnn_is_nnpa_conversion_installed","title":"zdnn_is_nnpa_conversion_installed","text":""},{"location":"zDNN/#description_8","title":"Description","text":"<p>Query, from zDNN internal memory, if requested NNPA data-type to/from BFP format conversions are installed.</p>"},{"location":"zDNN/#format_8","title":"Format","text":"<pre><code>bool zdnn_is_nnpa_conversion_installed(nnpa_data_type type,\n                                       uint16_t format_bitmask);\n</code></pre>"},{"location":"zDNN/#parameters_8","title":"Parameters","text":"<ul> <li> <p><code>nnpa_data_type type</code></p> </li> <li> <p>NNPA data-type number as defined in nnpa_data_type enum</p> </li> </ul> <pre><code>NNPA_DATATYPE_1\n</code></pre> <ul> <li> <p><code>uint16_t format_bitmask</code></p> </li> <li> <p>OR'd BFP format bitmasks as defined in zdnn_query_bfpfmts enum</p> </li> </ul> <pre><code>QUERY_BFPFMT_TINY (FP16)\nQUERY_BFPFMT_SHORT (FP32/BFLOAT)\n</code></pre>"},{"location":"zDNN/#returns_8","title":"Returns","text":"<p><code>true</code> if all queried conversions are installed, <code>false</code> otherwise.</p>"},{"location":"zDNN/#zdnn_get_library_version","title":"zdnn_get_library_version","text":""},{"location":"zDNN/#description_9","title":"Description","text":"<p>Retrieve library version number as a 32-bit hex value (<code>0x00[major][minor][patch]</code>).</p>"},{"location":"zDNN/#format_9","title":"Format","text":"<pre><code>uint32_t zdnn_get_library_version();\n</code></pre>"},{"location":"zDNN/#returns_9","title":"Returns","text":"<p>Library version number in <code>0x00[major][minor][patch]</code> format.</p>"},{"location":"zDNN/#zdnn_get_library_version_str","title":"zdnn_get_library_version_str","text":""},{"location":"zDNN/#description_10","title":"Description","text":"<p>Retrieve the library version number and build information as a string.</p>"},{"location":"zDNN/#format_10","title":"Format","text":"<pre><code>char *zdnn_get_library_version_str();\n</code></pre>"},{"location":"zDNN/#returns_10","title":"Returns","text":"<p>Library version number and build information as a string.</p>"},{"location":"zDNN/#zdnn_refresh_nnpa_query_result","title":"zdnn_refresh_nnpa_query_result","text":""},{"location":"zDNN/#description_11","title":"Description","text":"<p>Refresh zDNN in-memory query result from zAIU.</p>"},{"location":"zDNN/#format_11","title":"Format","text":"<pre><code>zdnn_status zdnn_refresh_nnpa_query_result();\n</code></pre>"},{"location":"zDNN/#parameters_9","title":"Parameters","text":"<p>None</p>"},{"location":"zDNN/#programming-notes_2","title":"Programming Notes","text":"<p>This is called automatically as a part of <code>zdnn_init</code> and should not need to be called directly. Manually refreshing query results before making other <code>zdnn_query_*</code> calls may noticeably impact performance.</p>"},{"location":"zDNN/#returns-zdnn_status-indications","title":"Returns zdnn_status indications","text":"<ul> <li><code>ZDNN_OK</code></li> <li><code>ZDNN_UNAVAILABLE_FUNCTION</code></li> </ul>"},{"location":"zDNN/#zdnn_getsize_ztensor","title":"zdnn_getsize_ztensor","text":""},{"location":"zDNN/#description_12","title":"Description","text":"<p>Used to determine the buffer size required for the transformed tensor (including concatenated) in zDNN transformed format. Requires tensor descriptor (<code>zdnn_tensor_desc</code>) with transformed shape information.</p>"},{"location":"zDNN/#format_12","title":"Format","text":"<pre><code>uint64_t zdnn_getsize_ztensor(const zdnn_tensor_desc *tfrmd_desc);\n</code></pre>"},{"location":"zDNN/#parameters_10","title":"Parameters","text":"<ul> <li> <p><code>zdnn_tensor_desc *tfrmd_desc</code></p> </li> <li> <p>Contains transformed information about the shape, layout and data type.</p> </li> </ul>"},{"location":"zDNN/#returns-zdnn_status-indications_1","title":"Returns zdnn_status indications","text":"<ul> <li>required buffer size in bytes</li> </ul>"},{"location":"zDNN/#zdnn_init_pre_transformed_desc","title":"zdnn_init_pre_transformed_desc","text":""},{"location":"zDNN/#description_13","title":"Description","text":"<p>Initialize tensor descriptor (<code>zdnn_tensor_desc</code>) struct with pre-transformed (original) shape information.</p>"},{"location":"zDNN/#format_13","title":"Format","text":"<pre><code>void zdnn_init_pre_transformed_desc(zdnn_data_layouts layout,\n                                    zdnn_data_types type,\n                                    zdnn_tensor_desc *pre_tfrmd_desc, ...);\n</code></pre>"},{"location":"zDNN/#parameters_11","title":"Parameters","text":"<ul> <li> <p><code>zdnn_data_layouts layout</code></p> </li> <li> <p>data layout</p> </li> <li> <p><code>zdnn_data_types type</code></p> </li> <li> <p>data type</p> </li> <li> <p><code>zdnn_tensor_desc *pre_tfrmd_desc</code></p> </li> <li> <p>output zdnn_tensor_desc struct</p> </li> <li> <p><code>... (additional arguments)</code></p> </li> <li> <p>Variadic: number of elements in each dimension in accordance to the layout,     in outermost to innermost order</p> </li> </ul>"},{"location":"zDNN/#returns_11","title":"Returns","text":"<ul> <li>None</li> </ul>"},{"location":"zDNN/#zdnn_generate_transformed_desc","title":"zdnn_generate_transformed_desc","text":""},{"location":"zDNN/#description_14","title":"Description","text":"<p>Generate transformed tensor descriptor information based on supplied pre-transformed tensor descriptor.</p>"},{"location":"zDNN/#format_14","title":"Format","text":"<pre><code>zdnn_status zdnn_generate_transformed_desc(\n    const zdnn_tensor_desc *pre_tfrmd_desc, zdnn_tensor_desc *tfrmd_desc);\n</code></pre>"},{"location":"zDNN/#parameters_12","title":"Parameters","text":"<ul> <li> <p><code>zdnn_tensor_desc *pre_tfrmd_desc</code></p> </li> <li> <p>input tensor descriptor with pre-transformed shape information</p> </li> <li> <p><code>zdnn_tensor_desc *tfrmd_desc</code></p> </li> <li> <p>output <code>zdnn_tensor_desc</code> struct</p> </li> </ul>"},{"location":"zDNN/#zdnn_status-indications","title":"zdnn_status indications","text":"<ul> <li><code>ZDNN_OK</code></li> <li><code>ZDNN_INVALID_LAYOUT</code> - pre-transformed <code>layout</code> is not recognized or is a   layout only used for concatenated tensors.</li> </ul>"},{"location":"zDNN/#zdnn_generate_transformed_desc_concatenated","title":"zdnn_generate_transformed_desc_concatenated","text":""},{"location":"zDNN/#description_15","title":"Description","text":"<p>Generate concatenated transformed tensor descriptor information for RNN input-gates tensors based on a supplied pre-transformed tensor descriptor.</p>"},{"location":"zDNN/#format_15","title":"Format","text":"<pre><code>zdnn_status zdnn_generate_transformed_desc_concatenated(\n    const zdnn_tensor_desc *pre_tfrmd_desc,\n    zdnn_concat_info info, zdnn_tensor_desc *tfrmd_desc);\n</code></pre>"},{"location":"zDNN/#parameters_13","title":"Parameters","text":"<ul> <li> <p><code>zdnn_tensor_desc *pre_tfrmd_desc</code></p> </li> <li> <p>input tensor descriptor with pre-transformed shape information</p> </li> <li> <p><code>zdnn_concat_info info</code></p> </li> <li> <p>Information about how the tensors will be concatenated, consists of the     RNN_TYPE, PREV_LAYER and USAGE flags OR'd together:</p> <p>RNN_TYPE flags:</p> <ul> <li>RNN_TYPE_LSTM - For LSTM</li> <li>RNN_TYPE_GRU - For GRU</li> </ul> <p>PREV_LAYER flags:</p> <ul> <li>PREV_LAYER_UNI - Previous RNN layer is uni-directional</li> <li>PREV_LAYER_NONE - Previous layer is not a RNN layer</li> <li>PREV_LAYER_BIDIR - Previous RNN layer is bi-directional</li> </ul> <p>USAGE flags:</p> <ul> <li>USAGE_WEIGHTS - Concatenate as input weights</li> <li>USAGE_HIDDEN_WEIGHTS - Concatenate as input hidden-weights</li> <li>USAGE_BIASES - Concatenate as input biases</li> <li>USAGE_HIDDEN_BIASES - Concatenate as input hidden-biases</li> </ul> </li> <li> <p><code>zdnn_tensor_desc *tfrmd_desc</code></p> </li> <li> <p>output <code>zdnn_tensor_desc</code> struct</p> </li> </ul>"},{"location":"zDNN/#zdnn_status-indications_1","title":"zdnn_status indications","text":"<ul> <li><code>ZDNN_OK</code></li> <li><code>ZDNN_INVALID_LAYOUT</code> - pre-transformed <code>layout</code> is not recognized or is not   supported for concatenated tensors.</li> <li><code>ZDNN_INVALID_CONCAT_INFO</code> - invalid concatenation information.</li> </ul>"},{"location":"zDNN/#zdnn_init_ztensor","title":"zdnn_init_ztensor","text":""},{"location":"zDNN/#description_16","title":"Description","text":"<p>Initialize a <code>zdnn_ztensor</code> struct using the pre-transformed and transformed tensor shape information</p>"},{"location":"zDNN/#format_16","title":"Format","text":"<pre><code>void zdnn_init_ztensor(zdnn_tensor_desc *pre_tfrmd_desc,\n                       zdnn_tensor_desc *tfrmd_desc, zdnn_ztensor *output);\n</code></pre>"},{"location":"zDNN/#parameters_14","title":"Parameters","text":"<ul> <li> <p><code>zdnn_tensor_desc *pre_tfrmd_desc</code></p> </li> <li> <p>input tensor descriptor with pre-transformed shape information</p> </li> <li> <p><code>zdnn_tensor_desc *tfrmd_desc</code></p> </li> <li> <p>input tensor descriptor with transformed shape information</p> </li> <li> <p><code>zdnn_ztensor *output</code></p> </li> <li> <p>The <code>zdnn_ztensor</code> struct being initialized.</p> </li> </ul>"},{"location":"zDNN/#returns_12","title":"Returns","text":"<ul> <li>None</li> </ul>"},{"location":"zDNN/#zdnn_init_ztensor_with_malloc","title":"zdnn_init_ztensor_with_malloc","text":""},{"location":"zDNN/#description_17","title":"Description","text":"<p>Same functionality as <code>zdnn_init_ztensor</code>, and computes the size required for the tensor in the zDNN transformed format and allocates the storage for it. Sets <code>buffer</code> and <code>buffer_size</code> fields within <code>output</code>.</p>"},{"location":"zDNN/#format_17","title":"Format","text":"<pre><code>zdnn_status zdnn_init_ztensor_with_malloc(zdnn_tensor_desc *pre_tfrmd_desc,\n                                          zdnn_tensor_desc *tfrmd_desc,\n                                          zdnn_ztensor *output);\n</code></pre>"},{"location":"zDNN/#parameters_15","title":"Parameters","text":"<ul> <li> <p><code>zdnn_tensor_desc *pre_tfrmd_desc</code></p> </li> <li> <p>input tensor descriptor with pre-transformed shape information</p> </li> <li> <p><code>zdnn_tensor_desc *tfrmd_desc</code></p> </li> <li> <p>input tensor descriptor with transformed shape information</p> </li> <li> <p><code>zdnn_ztensor *output</code></p> </li> <li> <p>The <code>zdnn_ztensor</code> struct being initialized.</p> </li> </ul>"},{"location":"zDNN/#returns-zdnn_status-indications_2","title":"Returns zdnn_status indications","text":"<ul> <li><code>ZDNN_OK</code></li> <li><code>ZDNN_INVALID_FORMAT</code> - <code>tfrmd_desc-&gt;format</code> is not recognized.</li> <li><code>ZDNN_INVALID_TYPE</code> - <code>tfrmd_desc-&gt;type</code> is not recognized or is a   pre_tfrmd_desc type.</li> <li><code>ZDNN_INVALID_SHAPE</code> - (if any of the following are true)</li> <li>One of <code>tfrmd_desc-&gt;dim*</code> dimensions is 0.</li> <li>One of <code>tfrmd_desc-&gt;dim*</code> dimensions is greater than     <code>zdnn_get_nnpa_max_dim_idx_size</code>.<ul> <li>Note: concatenation dimensions have a smaller maximum size. See   LSTM or GRU.</li> </ul> </li> <li>The total number of tfrmd_desc elements is larger than     <code>zdnn_get_nnpa_max_tensor_size</code>.</li> <li><code>ZDNN_ALLOCATION_FAILURE</code> - Unable to allocate required memory on a 4K   boundary.</li> </ul>"},{"location":"zDNN/#zdnn_reset_ztensor","title":"zdnn_reset_ztensor","text":""},{"location":"zDNN/#description_18","title":"Description","text":"<p>Reset a <code>zdnn_ztensor</code> struct for reuse.</p> <p>Note this operation does not set or reset the <code>buffer</code> and <code>buffer_size</code> fields nor free the transformed area storage.</p>"},{"location":"zDNN/#format_18","title":"Format","text":"<pre><code>void zdnn_reset_ztensor(zdnn_ztensor *ztensor);\n</code></pre>"},{"location":"zDNN/#parameters_16","title":"Parameters","text":"<ul> <li> <p><code>zdnn_ztensor *output</code></p> </li> <li> <p>The <code>zdnn_ztensor</code> struct being reset.</p> </li> </ul>"},{"location":"zDNN/#returns_13","title":"Returns","text":"<ul> <li>None</li> </ul>"},{"location":"zDNN/#zdnn_allochelper_ztensor","title":"zdnn_allochelper_ztensor","text":""},{"location":"zDNN/#description_19","title":"Description","text":"<p>Calculate the size required for the tensor in the zDNN transformed format and allocate the needed storage, satisfying alignment requirements. Sets <code>buffer</code> and <code>buffer_size</code> fields within <code>ztensor</code>.</p> <p>Note that the calling application assumes ownership of this storage and is responsible for freeing it.</p>"},{"location":"zDNN/#format_19","title":"Format","text":"<pre><code>zdnn_status zdnn_allochelper_ztensor(zdnn_ztensor *ztensor);\n</code></pre>"},{"location":"zDNN/#parameters_17","title":"Parameters","text":"<ul> <li> <p><code>zdnn_ztensor *ztensor</code></p> </li> <li> <p>A <code>zdnn_ztensor</code> struct that contains the transformed shape information in     the <code>transformed_desc</code> field.</p> </li> </ul>"},{"location":"zDNN/#returns-zdnn_status-indications_3","title":"Returns zdnn_status indications","text":"<ul> <li><code>ZDNN_OK</code></li> <li><code>ZDNN_INVALID_FORMAT</code> - <code>ztensor-&gt;transformed_desc-&gt;format</code> is not recognized.</li> <li><code>ZDNN_INVALID_TYPE</code> - <code>ztensor-&gt;transformed_desc-&gt;type</code> is not recognized or   is a pre_transformed_desc type.</li> <li><code>ZDNN_INVALID_SHAPE</code> - (if any of the following are true)</li> <li>One of <code>ztensor-&gt;transformed_desc-&gt;dim*</code> dimensions is 0.</li> <li>One of <code>ztensor-&gt;transformed_desc-&gt;dim*</code> dimensions is greater than     <code>zdnn_get_nnpa_max_dim_idx_size</code>.<ul> <li>Note: concatenation dimensions have a smaller maximum size. See   LSTM or GRU.</li> </ul> </li> <li>The total number of transformed_desc elements is larger than     <code>zdnn_get_nnpa_max_tensor_size</code>.</li> <li><code>ZDNN_ALLOCATION_FAILURE</code> - Unable to allocate required memory on a 4K   boundary.</li> </ul>"},{"location":"zDNN/#zdnn_free_ztensor_buffer","title":"zdnn_free_ztensor_buffer","text":""},{"location":"zDNN/#description_20","title":"Description","text":"<p>Given an input zdnn_ztensor, zdnn_free_ztensor_buffer will free the transformed area storage associated with it.</p> <p>Note that the routine does not free the storage allocated for the zdnn_ztensor struct itself.</p>"},{"location":"zDNN/#format_20","title":"Format","text":"<pre><code>zdnn_status zdnn_free_ztensor_buffer(const zdnn_ztensor *ztensor);\n</code></pre>"},{"location":"zDNN/#parameters_18","title":"Parameters","text":"<ul> <li> <p><code>zdnn_ztensor *tensor</code></p> </li> <li> <p>A <code>zdnn_ztensor</code> struct with field buffer pointing to storage allocated.</p> </li> </ul>"},{"location":"zDNN/#returns-zdnn_status-indications_4","title":"Returns zdnn_status indications","text":"<ul> <li><code>ZDNN_OK</code></li> <li><code>ZDNN_INVALID_BUFFER</code> - <code>tensor-&gt;buffer</code> is <code>NULL</code></li> </ul>"},{"location":"zDNN/#zdnn_get_status_message","title":"zdnn_get_status_message","text":""},{"location":"zDNN/#description_21","title":"Description","text":"<p>Retrieve status message of the status code</p>"},{"location":"zDNN/#format_21","title":"Format","text":"<pre><code>const char *zdnn_get_status_message(zdnn_status status);\n</code></pre>"},{"location":"zDNN/#parameters_19","title":"Parameters","text":"<ul> <li> <p><code>zdnn_status status</code></p> </li> <li> <p>Status code</p> </li> </ul>"},{"location":"zDNN/#returns_14","title":"Returns","text":"<p>Pointer to the description string or \"(Status string is not defined.)\" if <code>status</code> is not defined.</p>"},{"location":"zDNN/#zdnn_reshape_ztensor","title":"zdnn_reshape_ztensor","text":""},{"location":"zDNN/#description_22","title":"Description","text":"<p>Reshape and copy buffer content from source zTensor's buffer to destination zTensor's in accordance to destination zTensor's shape.</p> <p>The following conditions must be satisfied:</p> <ul> <li>Both tensor's transformed_desc must be fully initialized</li> <li><code>dest-&gt;buffer</code> must be pre-allocated</li> <li><code>src</code> must be transformed</li> <li><code>dest</code> must be not already transformed</li> <li>Both <code>transformed_desc-&gt;layout</code> must be the same and either NHWC or HWCK</li> <li>Both zTensors must contain equal number of elements</li> </ul>"},{"location":"zDNN/#format_22","title":"Format","text":"<pre><code>zdnn_status zdnn_reshape_ztensor(const zdnn_ztensor *src, zdnn_ztensor *dest);\n</code></pre>"},{"location":"zDNN/#parameters_20","title":"Parameters","text":"<ul> <li> <p><code>src</code></p> </li> <li> <p>Source zTensor to copy from</p> </li> <li> <p><code>dest</code></p> </li> <li> <p>Destination zTensor to copy to</p> </li> </ul>"},{"location":"zDNN/#programming-notes_3","title":"Programming Notes","text":"<ul> <li> <p>If <code>src</code> and <code>dest</code> have the same <code>transformed_desc-&gt;dim1</code> dimension size, the   transformed data is directly copied to the destination without   untransformation.</p> </li> <li> <p>If <code>src</code> and <code>dest</code> have different <code>transformed_desc-&gt;dim1</code> dimension sizes,   reshaping will internally un-transform the source and then re-transform the   values into the destination.</p> </li> </ul>"},{"location":"zDNN/#returns_15","title":"Returns","text":"<ul> <li><code>ZDNN_OK</code></li> <li><code>ZDNN_INVALID_SHAPE</code> - (if any of the following are true)</li> <li><code>src</code>'s and <code>dest</code>'s <code>transformed_desc-&gt;dim*</code> total to different numbers of     elements.</li> <li>One of <code>dest-&gt;transformed_desc-&gt;dim*</code> dimensions is 0.</li> <li>One of <code>dest-&gt;transformed_desc-&gt;dim*</code> dimensions is greater than     <code>zdnn_get_nnpa_max_dim_idx_size</code>.<ul> <li>Note: concatenation dimensions have a smaller maximum size. See   LSTM or GRU.</li> </ul> </li> <li>The total number of <code>dest-&gt;transformed_desc-dim*</code> elements is larger than     <code>zdnn_get_nnpa_max_tensor_size</code>.</li> <li><code>ZDNN_INVALID_LAYOUT</code> - (if any of the following are true)</li> <li><code>src</code>'s and <code>dest</code>'s <code>transformed_desc-&gt;layout</code> are not the same.</li> <li><code>transformed_desc-&gt;layout</code> is not <code>ZDNN_NHWC</code> nor <code>ZDNN_HWCK</code>.</li> <li><code>src-&gt;pre_transformed_desc-&gt;layout</code> is not recognized or is not a valid     pre_transformed_desc layout.</li> <li><code>dest-&gt;pre_transformed_desc-&gt;layout</code> is not recognized or is not a valid     pre_transformed_desc layout.</li> <li><code>ZDNN_INVALID_STATE</code> - (if any of the following are true)</li> <li><code>src</code> is not already transformed.</li> <li><code>dest</code> is already transformed.</li> <li><code>ZDNN_INVALID_FORMAT</code> - <code>src-&gt;transformed_desc-&gt;format</code> is not   <code>ZDNN_FORMAT_4DFEATURE</code>.</li> <li><code>ZDNN_INVALID_TYPE</code> (if any of the following are true)</li> <li><code>src-&gt;pre_transformed_desc-&gt;type</code> is not recognized or is a transformed_desc     type.</li> <li><code>dest-&gt;pre_transformed_desc-&gt;type</code> is not recognized or is a     transformed_desc type.</li> <li><code>dest-&gt;transformed_desc-&gt;type</code> is not recognized or is a     pre_transformed_desc type.</li> <li><code>ZDNN_INVALID_BUFFER</code> (if any of the following are true)</li> <li><code>src-&gt;buffer</code> is <code>NULL</code>.</li> <li><code>src-&gt;buffer</code> is not on a 4K boundary.</li> <li><code>dest-&gt;buffer</code> is <code>NULL</code>.</li> <li><code>dest-&gt;buffer</code> is not on a 4K boundary.</li> <li><code>dest-&gt;buffer_size</code> is too small to hold transformed values.</li> <li><code>ZDNN_CONVERT_FAILURE</code> - Values failed to un-transform or transform.</li> </ul>"},{"location":"zDNN/#zdnn_is_version_runnable","title":"zdnn_is_version_runnable","text":""},{"location":"zDNN/#description_23","title":"Description","text":"<p>Check if application built for zDNN version <code>ver_num</code> can be run on the current AIU hardware with the installed zDNN library</p>"},{"location":"zDNN/#format_23","title":"Format","text":"<pre><code>bool zdnn_is_version_runnable(uint32_t ver_num);\n</code></pre>"},{"location":"zDNN/#parameters_21","title":"Parameters","text":"<ul> <li> <p><code>ver_num</code></p> </li> <li> <p>zDNN version number from the application in 0x00[major][minor][patch] form.     Typically this is ZDNN_VERNUM used to compile the application</p> </li> </ul>"},{"location":"zDNN/#returns_16","title":"Returns","text":"<ul> <li>true/false</li> </ul>"},{"location":"zDNN/#zdnn_get_max_runnable_version","title":"zdnn_get_max_runnable_version","text":""},{"location":"zDNN/#description_24","title":"Description","text":"<p>Returns the maximum zDNN version number that the current hardware and installed zDNN library can run together. The returned value means the current runtime environment fully supports zDNN APIs set of that <code>major</code>.<code>minor</code> version and below.</p>"},{"location":"zDNN/#format_24","title":"Format","text":"<pre><code>uint32_t zdnn_get_max_runnable_version();\n</code></pre>"},{"location":"zDNN/#parameters_22","title":"Parameters","text":"<ul> <li>None</li> </ul>"},{"location":"zDNN/#returns_17","title":"Returns","text":"<ul> <li>A 32-bit zDNN version number in 0x00[major][minor]FF form.</li> </ul>"},{"location":"zDNN/#data-transformation","title":"Data Transformation","text":"<p>Back to Table of Contents</p> <ul> <li>Transform to zTensor</li> <li>Transform to Original</li> </ul> <p>zAIU requires the tensor data to be arranged in a format that enhances the performance characteristics of the operations. In this documentation, it is referred to as \"transformed format\". In addition, data conversions are necessary from the common formats (FP32, FP16, BFLOAT) to the internal format (DLFLOAT16) supported by the AIU. Two functions are provided:</p> <ul> <li> <p>'<code>zdnn_transform_ztensor</code></p> </li> <li> <p>zdnn_transform_ztensor will transform the input tensor and convert the input     data to the format required by the AIU. The resulting transformed ztensor     can be reused as many times as necessary.</p> </li> <li> <p>See zdnn_transform_ztensor for details on     transforming an input tensor to the internal format.</p> </li> <li> <p><code>zdnn_transform_origtensor</code></p> </li> <li> <p>zdnn_transform_origtensor transforms a ztensor (usually output from an     operation or network) to the format and data types that are usable by the     application.</p> </li> <li> <p>See zdnn_transform_origtensor for details on     transforming an input tensor to the internal format.</p> </li> </ul>"},{"location":"zDNN/#zdnn_transform_ztensor","title":"zdnn_transform_ztensor","text":""},{"location":"zDNN/#description_25","title":"Description","text":"<p>Converts the input tensor to the supported transformed format for execution by zdnn operations. If transformation is successful the <code>is_transformed</code> field within <code>ztensor</code> will be set to <code>true</code> otherwise it is set to <code>false</code>. Transformation will fail if <code>is_transformed</code> was already <code>true</code>.</p> <p>Note that the tensor layout in memory, once in transformed format, is dependent on the content of the input tensor's descriptors (<code>zdnn_tensor_desc</code> fields). Once converted, a <code>zdnn_ztensor</code> should only be manipulated by zDNN API functions.</p>"},{"location":"zDNN/#format_25","title":"Format","text":"<pre><code>zdnn_status zdnn_transform_ztensor(zdnn_ztensor *ztensor, ...);\n</code></pre>"},{"location":"zDNN/#parameters_23","title":"Parameters","text":"<ul> <li> <p><code>zdnn_ztensor *tensor</code></p> </li> <li> <p>The input <code>zdnn_ztensor</code> struct. <code>pre_transformed_desc</code> and     <code>transformed_desc</code> must be set, <code>is_transformed</code> must be <code>false</code>. A     4k-aligned tensor storage must be pre-allocated by the caller (directly or     by calling the zDNN allocation helper function) and field <code>buffer</code> must     point to the storage.</p> </li> <li> <p><code>... (additional arguments)</code></p> </li> <li> <p>Variadic: list of pointers for input data to be transformed:</p> <ul> <li>Non-concatenated: 1 data pointer</li> <li>LSTM concatenated: 4 data pointers, one for each input gate in Forget,   Input, Cell, Output (FICO) order</li> <li>GRU concatenated: 3 data pointers, one for each input gate in (Z)update,   Reset, Hidden, (ZRH) gate order</li> </ul> </li> </ul>"},{"location":"zDNN/#programming-notes_4","title":"Programming Notes","text":"<ul> <li>This function clears the pre-thread floating-point exception flags at entry,   and may set <code>FE_UNDERFLOW</code> / <code>FE_INVALID</code> / <code>FE_INEXACT</code> / <code>FE_OVERFLOW</code> when   it encounters errors during data conversion.</li> </ul>"},{"location":"zDNN/#returns-zdnn_status-indications_5","title":"Returns zdnn_status indications","text":"<ul> <li><code>ZDNN_OK</code></li> <li><code>ZDNN_INVALID_FORMAT</code> - <code>zdnn_ztensor-&gt;transformed_desc-&gt;format</code> is not   recognized.</li> <li><code>ZDNN_INVALID_LAYOUT</code> - (if any of the following are true)</li> <li><code>zdnn_ztensor-&gt;pre_transformed_desc-&gt;layout</code> is not recognized or is not a     valid pre_transformed_desc layout.</li> <li><code>zdnn_ztensor-&gt;transformed_desc-&gt;layout</code> is not recognized or is not a valid     transformed_desc layout.</li> <li><code>ZDNN_INVALID_TYPE</code> - (if any of the following are true)</li> <li><code>zdnn_ztensor-&gt;pre_transformed_desc-&gt;type</code> is not recognized or is a     transformed_desc type.</li> <li><code>zdnn_ztensor-&gt;transformed_desc-&gt;type</code> is not recognized or is a     pre_transformed_desc type.</li> <li><code>ZDNN_INVALID_BUFFER</code> (if any of the following are true)</li> <li><code>buffer</code> is <code>NULL</code>.</li> <li><code>buffer</code> is not on a 4K boundary.</li> <li><code>buffer_size</code> is too small to hold transformed values.</li> <li><code>ZDNN_INVALID_SHAPE</code> - (if any of the following are true)</li> <li>One of <code>zdnn_ztensor-&gt;transformed_desc-&gt;dim*</code> dimensions is 0.</li> <li>One of <code>zdnn_ztensor-&gt;transformed_desc-&gt;dim*</code> dimensions is greater than     <code>zdnn_get_nnpa_max_dim_idx_size</code>.<ul> <li>Note: concatenation dimensions have a smaller maximum size. See   LSTM or GRU.</li> </ul> </li> <li>The total number of transformed_desc elements is larger than     <code>zdnn_get_nnpa_max_tensor_size</code>.</li> <li><code>ZDNN_INVALID_STATE</code> - Tensor is already transformed.</li> <li><code>ZDNN_CONVERT_FAILURE</code> - Values failed to transform.</li> </ul>"},{"location":"zDNN/#zdnn_transform_origtensor","title":"zdnn_transform_origtensor","text":""},{"location":"zDNN/#description_26","title":"Description","text":"<p>Converts the input tensor from the zDNN transformed format back to a standard non-transformed layout. The <code>is_transformed</code> field within <code>ztensor</code> must be <code>true</code>.</p> <p>All stick format tensors are supported, except:</p> <ul> <li>Kernel tensors</li> <li>Concatenated RNN input-gates tensors</li> </ul>"},{"location":"zDNN/#format_26","title":"Format","text":"<pre><code>zdnn_status zdnn_transform_origtensor(const zdnn_ztensor *ztensor, void *out_buf);\n</code></pre>"},{"location":"zDNN/#parameters_24","title":"Parameters","text":"<ul> <li> <p><code>zdnn_ztensor *ztensor</code></p> </li> <li> <p>The input <code>zdnn_ztensor</code> struct. <code>pre_transformed_desc</code>, <code>transformed_desc</code>     and <code>buffer</code> must be set, <code>is_transformed</code> must be <code>true</code>.</p> </li> <li> <p><code>void *out_buf</code></p> </li> <li> <p>The buffer for storing the standard non-transformed tensor data. Must be     pre-allocated by the caller.</p> </li> </ul>"},{"location":"zDNN/#programming-notes_5","title":"Programming Notes","text":"<ul> <li>This function clears the pre-thread floating-point exception flags at entry,   and may set <code>FE_UNDERFLOW</code> / <code>FE_INVALID</code> / <code>FE_INEXACT</code> / <code>FE_OVERFLOW</code> when   it encounters errors during data conversion.</li> </ul>"},{"location":"zDNN/#returns-zdnn_status-indications_6","title":"Returns zdnn_status indications","text":"<ul> <li><code>ZDNN_OK</code></li> <li><code>ZDNN_INVALID_FORMAT</code> - <code>ztensor-&gt;transformed_desc-&gt;format</code> is not   <code>ZDNN_FORMAT_4DFEATURE</code>.</li> <li><code>ZDNN_INVALID_LAYOUT</code> - (if any of the following are true)</li> <li><code>zdnn_ztensor-&gt;pre_transformed_desc-&gt;layout</code> is not recognized or is not a     valid pre_transformed_desc layout.</li> <li><code>zdnn_ztensor-&gt;transformed_desc-&gt;layout</code> is not recognized or is not a valid     transformed_desc layout required by this function.</li> <li><code>ZDNN_INVALID_TYPE</code></li> <li><code>ztensor-&gt;pre_transformed_desc-&gt;type</code> is not recognized or is a     transformed_desc type.</li> <li><code>ztensor-&gt;transformed_desc-&gt;type</code> is not recognized or is a     pre_transformed_desc type.</li> <li><code>ZDNN_INVALID_BUFFER</code> (if any of the following are true)</li> <li><code>ztensor-&gt;buffer</code> is <code>NULL</code>.</li> <li><code>ztensor-&gt;buffer</code> is not on a 4K boundary.</li> <li><code>ZDNN_INVALID_STATE</code> - <code>ztensor</code> is not transformed.</li> <li><code>ZDNN_CONVERT_FAILURE</code> - Values failed to un-transform.</li> </ul>"},{"location":"zDNN/#operations","title":"Operations","text":"<p>See Table of Contents for operations list</p>"},{"location":"zDNN/#element-wise-operations","title":"Element-wise Operations","text":"<p>Back to Table of Contents</p> <ul> <li>Addition</li> <li>Subtraction</li> <li>Multiplication</li> <li>Division</li> <li>Minimum</li> <li>Maximum</li> <li>Natural Logarithm</li> <li>Exponential</li> </ul>"},{"location":"zDNN/#zdnn_add","title":"zdnn_add","text":"<ul> <li>Back to Table of Contents</li> <li>Back to Element-wise Operations</li> </ul>"},{"location":"zDNN/#description_27","title":"Description","text":"<p>Given two input tensors in zDNN transformed format, performs element-wise addition and stores the result into the provided output zDNN tensor.</p> <p>Note that for zDNN use, broadcasting of the input tensor(s) must be performed by the caller. As such, the input tensors must be of the same shape.</p>"},{"location":"zDNN/#format_27","title":"Format","text":"<pre><code>zdnn_status zdnn_add(const zdnn_ztensor *input_a, const zdnn_ztensor *input_b,\n                     zdnn_ztensor *output);\n</code></pre>"},{"location":"zDNN/#parameters_25","title":"Parameters","text":"<ul> <li> <p><code>zdnn_ztensor *input_a</code></p> </li> <li> <p>Tensor with addends to add to <code>input_b</code> tensor</p> </li> <li> <p>Must follow general tensor requirements</p> </li> <li> <p><code>zdnn_ztensor *input_b</code></p> </li> <li> <p>Tensor with addends to add to <code>input_a</code> tensor</p> </li> <li> <p>Must follow general tensor requirements</p> </li> <li> <p><code>zdnn_ztensor *output</code></p> </li> <li>Tensor to hold the result of the addition</li> <li>Must follow general tensor requirements</li> </ul>"},{"location":"zDNN/#returns-see-zdnn-statuses-for-descriptions","title":"Returns (see zDNN Statuses for descriptions)","text":"<ul> <li><code>ZDNN_OK</code></li> <li>warning statuses</li> <li><code>ZDNN_INVALID_SHAPE</code></li> <li><code>ZDNN_INVALID_TYPE</code></li> <li><code>ZDNN_INVALID_FORMAT</code></li> <li>hardware statuses</li> </ul>"},{"location":"zDNN/#framework-examples","title":"Framework Examples","text":"<p>TensorFlow Addition</p> <p>ONNX Addition</p>"},{"location":"zDNN/#zdnn_sub","title":"zdnn_sub","text":"<ul> <li>Back to Table of Contents</li> <li>Back to Element-wise Operations</li> </ul>"},{"location":"zDNN/#description_28","title":"Description","text":"<p>Given two input tensors in zDNN transformed format, performs element-wise subtraction and stores the result into the provided output zDNN tensor.</p> <p>Note that for zDNN use, broadcasting of the input tensor(s) must be performed by the caller. As such, the input tensors must be of the same shape.</p>"},{"location":"zDNN/#format_28","title":"Format","text":"<pre><code>zdnn_status zdnn_sub(const zdnn_ztensor *input_a, const zdnn_ztensor *input_b,\n                     zdnn_ztensor *output);\n</code></pre>"},{"location":"zDNN/#parameters_26","title":"Parameters","text":"<ul> <li> <p><code>zdnn_ztensor *input_a</code></p> </li> <li> <p>Tensor with minuends that will be subtracted by <code>input_b</code> tensor.</p> </li> <li> <p>Must follow general tensor requirements</p> </li> <li> <p><code>zdnn_ztensor *input_b</code></p> </li> <li> <p>Tensor with subtrahends to subtract from <code>input_a</code> tensor.</p> </li> <li> <p>Must follow general tensor requirements</p> </li> <li> <p><code>zdnn_ztensor *output</code></p> </li> <li>Tensor to hold the result of the subtraction</li> <li>Must follow general tensor requirements</li> </ul>"},{"location":"zDNN/#returns-see-zdnn-statuses-for-descriptions_1","title":"Returns (see zDNN Statuses for descriptions)","text":"<ul> <li><code>ZDNN_OK</code></li> <li>warning statuses</li> <li><code>ZDNN_INVALID_SHAPE</code></li> <li><code>ZDNN_INVALID_TYPE</code></li> <li><code>ZDNN_INVALID_FORMAT</code></li> <li>hardware statuses</li> </ul>"},{"location":"zDNN/#framework-examples_1","title":"Framework Examples","text":"<p>TensorFlow Subtraction</p> <p>https://www.tensorflow.org/api_docs/python/tf/math/subtract</p> <p>ONNX Subtraction</p> <p>https://github.com/onnx/onnx/blob/master/docs/Operators.md#sub</p>"},{"location":"zDNN/#zdnn_mul","title":"zdnn_mul","text":"<ul> <li>Back to Table of Contents</li> <li>Back to Element-wise Operations</li> </ul>"},{"location":"zDNN/#description_29","title":"Description","text":"<p>Given two input tensors in zDNN transformed format, performs element-wise multiplication and stores the result into the provided output zDNN tensor.</p> <p>Note that for zDNN use, broadcasting of the input tensor(s) must be performed by the caller. As such, the input tensors must be of the same shape.</p>"},{"location":"zDNN/#format_29","title":"Format","text":"<pre><code>zdnn_status zdnn_mul(const zdnn_ztensor *input_a, const zdnn_ztensor *input_b,\n                     zdnn_ztensor *output);\n</code></pre>"},{"location":"zDNN/#parameters_27","title":"Parameters","text":"<ul> <li> <p><code>zdnn_ztensor *input_a</code></p> </li> <li> <p>Tensor with multiplicands that will be multiplied by <code>input_b</code> tensor.</p> </li> <li> <p>Must follow general tensor requirements</p> </li> <li> <p><code>zdnn_ztensor *input_b</code></p> </li> <li> <p>Tensor with multipliers for <code>input_a</code> tensor.</p> </li> <li> <p>Must follow general tensor requirements</p> </li> <li> <p><code>zdnn_ztensor *output</code></p> </li> <li>Tensor to hold the result of the multiplication.</li> <li>Must follow general tensor requirements</li> </ul>"},{"location":"zDNN/#returns-see-zdnn-statuses-for-descriptions_2","title":"Returns (see zDNN Statuses for descriptions)","text":"<ul> <li><code>ZDNN_OK</code></li> <li>warning statuses</li> <li><code>ZDNN_INVALID_SHAPE</code></li> <li><code>ZDNN_INVALID_TYPE</code></li> <li><code>ZDNN_INVALID_FORMAT</code></li> <li>hardware statuses</li> </ul>"},{"location":"zDNN/#framework-examples_2","title":"Framework Examples","text":"<p>TensorFlow Multiplication</p> <p>https://www.tensorflow.org/api_docs/python/tf/math/multiply</p> <p>ONNX Multiplication</p> <p>https://github.com/onnx/onnx/blob/master/docs/Operators.md#Mul</p>"},{"location":"zDNN/#zdnn_div","title":"zdnn_div","text":"<ul> <li>Back to Table of Contents</li> <li>Back to Element-wise Operations</li> </ul>"},{"location":"zDNN/#description_30","title":"Description","text":"<p>Given two input tensors in zDNN transformed format, performs element-wise division and stores the result into the provided output zDNN tensor.</p> <p>Note that for zDNN use, broadcasting of the input tensor(s) must be performed by the caller. As such, the input tensors must be of the same shape.</p>"},{"location":"zDNN/#format_30","title":"Format","text":"<pre><code>zdnn_status zdnn_div(const zdnn_ztensor *input_a, const zdnn_ztensor *input_b,\n                     zdnn_ztensor *output);\n</code></pre>"},{"location":"zDNN/#parameters_28","title":"Parameters","text":"<ul> <li> <p><code>zdnn_ztensor *input_a</code></p> </li> <li> <p>Tensor with dividends that will be divided by <code>input_b</code> tensor.</p> </li> <li> <p>Must follow general tensor requirements</p> </li> <li> <p><code>zdnn_ztensor *input_b</code></p> </li> <li> <p>Tensor with divisors for <code>input_a</code> tensor.</p> </li> <li> <p>Must follow general tensor requirements</p> </li> <li> <p><code>zdnn_ztensor *output</code></p> </li> <li>Tensor to hold the result of the division.</li> <li>Must follow general tensor requirements</li> </ul>"},{"location":"zDNN/#returns-see-zdnn-statuses-for-descriptions_3","title":"Returns (see zDNN Statuses for descriptions)","text":"<ul> <li><code>ZDNN_OK</code></li> <li>warning statuses</li> <li><code>ZDNN_INVALID_SHAPE</code></li> <li><code>ZDNN_INVALID_TYPE</code></li> <li><code>ZDNN_INVALID_FORMAT</code></li> <li>hardware statuses</li> </ul>"},{"location":"zDNN/#framework-examples_3","title":"Framework Examples","text":"<p>TensorFlow Division</p> <p>ONNX Division</p>"},{"location":"zDNN/#zdnn_min","title":"zdnn_min","text":"<ul> <li>Back to Table of Contents</li> <li>Back to Element-wise Operations</li> </ul>"},{"location":"zDNN/#description_31","title":"Description","text":"<p>Given two input tensors in zDNN transformed format, computes the element-wise minimum and stores the result into the provided output zDNN tensor.</p> <p>Note that for zDNN use, broadcasting of the input tensor(s) must be performed by the caller. As such, the input tensors must be of the same shape.</p>"},{"location":"zDNN/#format_31","title":"Format","text":"<pre><code>zdnn_status zdnn_min(const zdnn_ztensor *input_a, const zdnn_ztensor *input_b,\n                     zdnn_ztensor *output);\n</code></pre>"},{"location":"zDNN/#parameters_29","title":"Parameters","text":"<ul> <li> <p><code>zdnn_ztensor *input_a</code></p> </li> <li> <p>Tensor with values that will be compared with <code>input_b</code> tensor.</p> </li> <li> <p>Must follow general tensor requirements</p> </li> <li> <p><code>zdnn_ztensor *input_b</code></p> </li> <li> <p>Tensor with values that will be compared with <code>input_a</code> tensor.</p> </li> <li> <p>Must follow general tensor requirements</p> </li> <li> <p><code>zdnn_ztensor *output</code></p> </li> <li>Tensor that holds the smaller value from each comparison of the inputs.</li> <li>Must follow general tensor requirements</li> </ul>"},{"location":"zDNN/#returns-see-zdnn-statuses-for-descriptions_4","title":"Returns (see zDNN Statuses for descriptions)","text":"<ul> <li><code>ZDNN_OK</code></li> <li>warning statuses</li> <li><code>ZDNN_INVALID_SHAPE</code></li> <li><code>ZDNN_INVALID_TYPE</code></li> <li><code>ZDNN_INVALID_FORMAT</code></li> <li>hardware statuses</li> </ul>"},{"location":"zDNN/#framework-examples_4","title":"Framework Examples","text":"<p>TensorFlow Minimum</p> <p>ONNX Minimum</p>"},{"location":"zDNN/#zdnn_max","title":"zdnn_max","text":"<ul> <li>Back to Table of Contents</li> <li>Back to Element-wise Operations</li> </ul>"},{"location":"zDNN/#description_32","title":"Description","text":"<p>Given two input tensors in zDNN transformed format, computes the element-wise maximum and stores the result into the provided output zDNN tensor.</p> <p>Note that for zDNN use, broadcasting of the input tensor(s) must be performed by the caller. As such, the input tensors must be of the same shape.</p>"},{"location":"zDNN/#format_32","title":"Format","text":"<pre><code>zdnn_status zdnn_max(const zdnn_ztensor *input_a, const zdnn_ztensor *input_b,\n                     zdnn_ztensor *output);\n</code></pre>"},{"location":"zDNN/#parameters_30","title":"Parameters","text":"<ul> <li> <p><code>zdnn_ztensor *input_a</code></p> </li> <li> <p>Tensor with values that will be compared with <code>input_b</code> tensor.</p> </li> <li> <p>Must follow general tensor requirements</p> </li> <li> <p><code>zdnn_ztensor *input_b</code></p> </li> <li> <p>Tensor with values that will be compared with <code>input_a</code> tensor.</p> </li> <li> <p>Must follow general tensor requirements</p> </li> <li> <p><code>zdnn_ztensor *output</code></p> </li> <li>Tensor that holds the larger value from each comparison of the inputs.</li> <li>Must follow general tensor requirements</li> </ul>"},{"location":"zDNN/#returns-see-zdnn-statuses-for-descriptionss","title":"Returns (see zDNN Statuses for descriptions)s","text":"<ul> <li><code>ZDNN_OK</code></li> <li>warning statuses</li> <li><code>ZDNN_INVALID_SHAPE</code></li> <li><code>ZDNN_INVALID_TYPE</code></li> <li><code>ZDNN_INVALID_FORMAT</code></li> <li>hardware statuses</li> </ul>"},{"location":"zDNN/#framework-examples_5","title":"Framework Examples","text":"<p>TensorFlow Maximum</p> <p>ONNX Maximum</p>"},{"location":"zDNN/#zdnn_log","title":"zdnn_log","text":"<ul> <li>Back to Table of Contents</li> <li>Back to Element-wise Operations</li> </ul>"},{"location":"zDNN/#description_33","title":"Description","text":"<p>Given an input tensor in zDNN transformed format, computes the natural logarithm element-wise and stores the result into the provided output zDNN tensor.</p>"},{"location":"zDNN/#format_33","title":"Format","text":"<pre><code>zdnn_status zdnn_log(const zdnn_ztensor *input, zdnn_ztensor *output);\n</code></pre>"},{"location":"zDNN/#parameters_31","title":"Parameters","text":"<ul> <li> <p><code>zdnn_ztensor *input</code></p> </li> <li> <p>Tensor with values to evaluate.</p> </li> <li> <p>Must follow general tensor requirements</p> </li> <li> <p><code>zdnn_ztensor *output</code></p> </li> <li>Tensor that holds the calculated natural logarithm of each value from     <code>input_a</code></li> <li>Must follow general tensor requirements</li> </ul>"},{"location":"zDNN/#returns-see-zdnn-statuses-for-descriptions_5","title":"Returns (see zDNN Statuses for descriptions)","text":"<ul> <li><code>ZDNN_OK</code></li> <li>warning statuses</li> <li><code>ZDNN_INVALID_SHAPE</code></li> <li><code>ZDNN_INVALID_TYPE</code></li> <li><code>ZDNN_INVALID_FORMAT</code></li> <li>hardware statuses</li> </ul>"},{"location":"zDNN/#framework-examples_6","title":"Framework Examples","text":"<p>TensorFlow Natural Logarithm</p> <p>https://www.tensorflow.org/api_docs/python/tf/math/log</p> <p>ONNX Natural Logarithm</p> <p>https://github.com/onnx/onnx/blob/master/docs/Operators.md#Log</p>"},{"location":"zDNN/#zdnn_exp","title":"zdnn_exp","text":"<ul> <li>Back to Table of Contents</li> <li>Back to Element-wise Operations</li> </ul>"},{"location":"zDNN/#description_34","title":"Description","text":"<p>Given an input tensor in zDNN transformed format, computes the exponential element-wise and stores the result into the provided output zDNN tensor.</p>"},{"location":"zDNN/#format_34","title":"Format","text":"<pre><code>zdnn_status zdnn_exp(const zdnn_ztensor *input, zdnn_ztensor *output);\n</code></pre>"},{"location":"zDNN/#parameters_32","title":"Parameters","text":"<ul> <li> <p><code>zdnn_ztensor *input</code></p> </li> <li> <p>Tensor with values to evaluate.</p> </li> <li> <p>Must follow general tensor requirements</p> </li> <li> <p><code>zdnn_ztensor *output</code></p> </li> <li>Tensor that holds the calculated exponential of each value from <code>input</code></li> <li>Must follow general tensor requirements</li> </ul>"},{"location":"zDNN/#returns-see-zdnn-statuses-for-descriptions_6","title":"Returns (see zDNN Statuses for descriptions)","text":"<ul> <li><code>ZDNN_OK</code></li> <li>warning statuses</li> <li><code>ZDNN_INVALID_SHAPE</code></li> <li><code>ZDNN_INVALID_TYPE</code></li> <li><code>ZDNN_INVALID_FORMAT</code></li> <li>hardware statuses</li> </ul>"},{"location":"zDNN/#framework-examples_7","title":"Framework Examples","text":"<p>TensorFlow Exponential</p> <p>ONNX Exponential</p> <p>https://github.com/onnx/onnx/blob/master/docs/Operators.md#Exp</p>"},{"location":"zDNN/#activation-operations","title":"Activation Operations","text":"<p>Back to Table of Contents</p> <ul> <li>Rectified Linear</li> <li>Hyperbolic Tangent</li> <li>Sigmoid</li> <li>Softmax</li> </ul>"},{"location":"zDNN/#zdnn_relu","title":"zdnn_relu","text":"<ul> <li>Back to Table of Contents</li> <li>Back to Activation Operations</li> </ul>"},{"location":"zDNN/#description_35","title":"Description","text":"<p>Given an input tensor in zDNN transformed format produce an output tensor where the rectified linear function, y = max(0, x) is applied to the input element-wise. If an optional clipping_value is provided, clipping is performed against the intermediate output where z = min(y, clipping_value).</p>"},{"location":"zDNN/#format_35","title":"Format","text":"<pre><code>zdnn_status zdnn_relu(const zdnn_ztensor *input, const void *clipping_value,\n                      zdnn_ztensor *output);\n</code></pre>"},{"location":"zDNN/#parameters_33","title":"Parameters","text":"<ul> <li> <p><code>zdnn_ztensor *input</code></p> </li> <li> <p>Tensor with values to evaluate.</p> </li> <li> <p>Must follow general tensor requirements</p> </li> <li> <p><code>void *clipping_value</code></p> </li> <li> <p>A pointer to an FP32 value, used to clip input tensor's elements.</p> </li> <li>If set to NULL or 0, no clipping will occur.</li> <li> <p>Must not be a negative value.</p> </li> <li> <p><code>zdnn_ztensor *output</code></p> </li> <li>Tensor that holds the rectified linear function result of each value from     <code>input</code></li> <li>Must follow general tensor requirements</li> </ul>"},{"location":"zDNN/#returns-see-zdnn-statuses-for-descriptions_7","title":"Returns (see zDNN Statuses for descriptions)","text":"<ul> <li><code>ZDNN_OK</code></li> <li>warning statuses</li> <li><code>ZDNN_INVALID_SHAPE</code></li> <li><code>ZDNN_INVALID_TYPE</code></li> <li><code>ZDNN_INVALID_FORMAT</code></li> <li><code>ZDNN_INVALID_CLIPPING_VALUE</code></li> <li>hardware statuses</li> </ul>"},{"location":"zDNN/#framework-examples_8","title":"Framework Examples","text":"<p>TensorFlow Rectified Linear</p> <p>https://www.tensorflow.org/api_docs/python/tf/nn/relu</p> <p>ONNX Rectified Linear</p> <p>https://github.com/onnx/onnx/blob/master/docs/Operators.md#relu</p>"},{"location":"zDNN/#zdnn_tanh","title":"zdnn_tanh","text":"<ul> <li>Back to Table of Contents</li> <li>Back to Activation Operations</li> </ul>"},{"location":"zDNN/#description_36","title":"Description","text":"<p>Given an input tensor in zDNN transformed format, produces an output tensor where the hyperbolic tangent is applied to the input element-wise.</p>"},{"location":"zDNN/#format_36","title":"Format","text":"<pre><code>zdnn_status zdnn_tanh(const zdnn_ztensor *input, zdnn_ztensor *output);\n</code></pre>"},{"location":"zDNN/#parameters_34","title":"Parameters","text":"<ul> <li> <p><code>zdnn_ztensor *input</code></p> </li> <li> <p>Tensor with values to evaluate.</p> </li> <li> <p>Must follow general tensor requirements</p> </li> <li> <p><code>zdnn_ztensor *output</code></p> </li> <li>Tensor that holds the hyperbolic tangent result of each value from <code>input</code></li> <li>Must follow general tensor requirements</li> </ul>"},{"location":"zDNN/#returns-see-zdnn-statuses-for-descriptions_8","title":"Returns (see zDNN Statuses for descriptions)","text":"<ul> <li><code>ZDNN_OK</code></li> <li>warning statuses</li> <li><code>ZDNN_INVALID_SHAPE</code></li> <li><code>ZDNN_INVALID_TYPE</code></li> <li><code>ZDNN_INVALID_FORMAT</code></li> <li>hardware statuses</li> </ul>"},{"location":"zDNN/#framework-examples_9","title":"Framework Examples","text":"<p>TensorFlow Hyperbolic Tangent</p> <p>https://www.tensorflow.org/api_docs/python/tf/math/tanh</p> <p>ONNX Hyperbolic Tangent</p> <p>https://github.com/onnx/onnx/blob/master/docs/Operators.md#Tanh</p>"},{"location":"zDNN/#zdnn_sigmoid","title":"zdnn_sigmoid","text":"<ul> <li>Back to Table of Contents</li> <li>Back to Activation Operations</li> </ul>"},{"location":"zDNN/#description_37","title":"Description","text":"<p>Given an input tensor in zDNN transformed format, produces an output tensor where the sigmoid function is applied to the input element-wise.</p>"},{"location":"zDNN/#format_37","title":"Format","text":"<pre><code>zdnn_status zdnn_sigmoid(const zdnn_ztensor *input, zdnn_ztensor *output);\n</code></pre>"},{"location":"zDNN/#parameters_35","title":"Parameters","text":"<ul> <li> <p><code>zdnn_ztensor *input</code></p> </li> <li> <p>Tensor with values to evaluate.</p> </li> <li> <p>Must follow general tensor requirements</p> </li> <li> <p><code>zdnn_ztensor *output</code></p> </li> <li>Tensor that holds the sigmoid result of each value from <code>input</code></li> <li>Must follow general tensor requirements</li> </ul>"},{"location":"zDNN/#returns-see-zdnn-statuses-for-descriptions_9","title":"Returns (see zDNN Statuses for descriptions)","text":"<ul> <li><code>ZDNN_OK</code></li> <li>warning statuses</li> <li><code>ZDNN_INVALID_SHAPE</code></li> <li><code>ZDNN_INVALID_TYPE</code></li> <li><code>ZDNN_INVALID_FORMAT</code></li> <li>hardware statuses</li> </ul>"},{"location":"zDNN/#framework-examples_10","title":"Framework Examples","text":"<p>TensorFlow Sigmoid</p> <p>ONNX Sigmoid</p> <p>https://github.com/onnx/onnx/blob/master/docs/Operators.md#Sigmoid</p>"},{"location":"zDNN/#zdnn_softmax","title":"zdnn_softmax","text":"<ul> <li>Back to Table of Contents</li> <li>Back to Activation Operations</li> </ul>"},{"location":"zDNN/#description_38","title":"Description","text":"<p>Given an input tensor in zDNN transformed format, computes the softmax (normalized exponential) for each vector formed in dimension-1, then if <code>act_func</code> is not <code>SOFTMAX_ACT_NONE</code>, the activation function is applied to the results. Finally stores the results into the provided output zDNN tensor.</p> <p>Note: Other parameters, such as axis, are not supported.</p>"},{"location":"zDNN/#format_38","title":"Format","text":"<pre><code>zdnn_status zdnn_softmax(const zdnn_ztensor *input, void *save_area,\n                         zdnn_softmax_act act_func, zdnn_ztensor *output);\n</code></pre>"},{"location":"zDNN/#parameters_36","title":"Parameters","text":"<ul> <li> <p><code>zdnn_ztensor *input</code></p> </li> <li> <p>ZDNN_3DS tensor with pre-transformed shape [batch size,     batch size, vector dimension size] or output from another operation that is     of the correct shape.</p> </li> <li> <p>Must follow general tensor requirements</p> </li> <li> <p><code>void *save_area</code></p> </li> <li> <p>A preallocated memory address to use for temporary storage during internal     operation processing.</p> </li> <li>The preallocate memory must be at least 8K bytes in size, aligned on a 4k     boundary.</li> <li> <p>If set to NULL, the operation will determine, allocate and free storage     automatically.</p> </li> <li> <p><code>zdnn_softmax_act act_func</code></p> </li> <li> <p>Activation function to apply to the results.</p> </li> <li> <p><code>SOFTMAX_ACT_NONE</code> or <code>SOFTMAX_ACT_LOG</code></p> </li> <li> <p><code>zdnn_ztensor *output</code></p> </li> <li>ZDNN_3DS tensor with the same shape as <code>input_a</code> that     holds the softmax result of each value from <code>input_a</code>.</li> <li>Must follow general tensor requirements</li> </ul>"},{"location":"zDNN/#programming-notes_6","title":"Programming Notes","text":"<ul> <li> <p>If all elements of a dimension 1 vector are the largest magnitude negative   number possible for the transformed data type, accuracy may be reduced.</p> </li> <li> <p>A <code>ZDNN_3DS</code> tensor is expected, where the <code>transformed_desc</code> dim1 describes   the vector, and dim2 and dim4 are used to batch multiple vector requests   together. Dim3 must always be 1. The <code>zdnn_softmax</code> operation is performed   against the vector in dim1 repeating for each dim1 vector in the dim4 and dim2   dimensions.</p> </li> <li> <p>Tensors that cannot be processed as vectors in dim1 or as batches of dim1   vectors must be coerced or reshaped by the caller.</p> </li> <li>When the entire tensor is to be processed by softmax, it can be coerced by     simply creating an alternate descriptor prior to zDNN transformation. For     example:<ul> <li>A 4D tensor with <code>pre_transformed_desc</code> dimensions 2x2x2x2 and a data   array of 16 FP32 entries could have an alternate <code>ZDNN_3DS</code> layout   <code>pre_transformed_desc</code> using dimensions 1x1x16 and use the same original   data array prior to <code>zdnn_transform_ztensor</code>. After transformation, such a   tensor would be valid for <code>zdnn_softmax</code>.</li> <li>In another example, the 4D 2x2x2x2 tensor could be processed as 2 batches   of 8 vectors using a <code>ZDNN_3DS</code> layout <code>pre_transformed_desc</code> with   dimensions 1x2x8.</li> </ul> </li> </ul>"},{"location":"zDNN/#returns-see-zdnn-statuses-for-descriptions_10","title":"Returns (see zDNN Statuses for descriptions)","text":"<ul> <li><code>ZDNN_OK</code></li> <li>warning statuses</li> <li><code>ZDNN_INVALID_SHAPE</code></li> <li><code>ZDNN_INVALID_TYPE</code></li> <li><code>ZDNN_INVALID_FORMAT</code></li> <li><code>ZDNN_ALLOCATION_FAILURE</code> - A preallocated <code>save_area</code> was not specified and   internal allocation for the required memory failed.</li> <li>hardware statuses</li> <li><code>ZDNN_FUNC_RC_F000</code> - input tensor <code>input-&gt;transformed_desc-&gt;dim3</code> was     not 1.</li> <li><code>ZDNN_FUNC_RC_F001</code> - Invalid <code>act_func</code></li> </ul>"},{"location":"zDNN/#framework-examples_11","title":"Framework Examples","text":"<p>TensorFlow Softmax</p> <p>ONNX Softmax</p> <p>https://github.com/onnx/onnx/blob/master/docs/Operators.md#Softmax</p>"},{"location":"zDNN/#normalization-operations","title":"Normalization Operations","text":"<p>Back to Table of Contents</p> <ul> <li>Mean Reduce</li> <li>Batch Norm</li> </ul>"},{"location":"zDNN/#zdnn_meanreduce2d","title":"zdnn_meanreduce2d","text":"<ul> <li>Back to Table of Contents</li> <li>Back to Normalization Operations</li> </ul>"},{"location":"zDNN/#description_39","title":"Description","text":"<p>Given an input tensor in zDNN transformed format, produces a downsampled tensor reducing the middle dimensions to a size of 1 based on the mean of the original values and stores the result to the provided output zDNN tensor.</p>"},{"location":"zDNN/#format_39","title":"Format","text":"<pre><code>zdnn_status zdnn_meanreduce2d(const zdnn_ztensor *input, zdnn_ztensor *output);\n</code></pre>"},{"location":"zDNN/#parameters_37","title":"Parameters","text":"<ul> <li> <p><code>zdnn_ztensor *input</code></p> </li> <li> <p>Must be a ZDNN_NHWC tensor with pre_transformed shape     [batch_Num, Height, Width, Channel].</p> </li> <li>Height and Width dimension must be less than or equal to 1024.</li> <li> <p>Must follow general tensor requirements</p> </li> <li> <p><code>zdnn_ztensor *output</code></p> </li> <li>The result tensor which will hold the result of the pooling operation in its     buffer.</li> <li>Shape:<ul> <li><code>output</code> dimensions batch_Num and Channel must be the same as the   respective input dimensions.</li> <li><code>output</code> dimensions Height and Width must be 1.</li> </ul> </li> <li>Must follow general tensor requirements</li> </ul>"},{"location":"zDNN/#returns-see-zdnn-statuses-for-descriptions_11","title":"Returns (see zDNN Statuses for descriptions)","text":"<ul> <li><code>ZDNN_OK</code></li> <li><code>ZDNN_INVALID_SHAPE</code> - Shape of input or output tensor is invalid based on   given kernel and stride parameters</li> <li><code>ZDNN_INVALID_TYPE</code></li> <li><code>ZDNN_INVALID_FORMAT</code></li> <li>hardware statuses</li> <li><code>ZDNN_FUNC_RC_F001</code> - <code>input</code> tensor has a Height or Width dimension greater     than allowed for <code>zdnn_meanreduce2d</code>.</li> </ul>"},{"location":"zDNN/#framework-examples_12","title":"Framework Examples","text":"<p>TensorFlow Reduce Mean with <code>axis</code> set for the Height and Width axes and <code>keepdims</code> set to True.</p> <p>https://www.tensorflow.org/api_docs/python/tf/math/reduce_mean</p> <p>ONNX Reduce Mean</p> <p>https://github.com/onnx/onnx/blob/master/docs/Operators.md#ReduceMean</p>"},{"location":"zDNN/#zdnn_batchnorm","title":"zdnn_batchnorm","text":"<ul> <li>Back to Table of Contents</li> <li>Back to Normalization Operations</li> </ul>"},{"location":"zDNN/#description_40","title":"Description","text":"<p>Given three input zDNN tensors <code>input_a</code>, <code>input_b</code>, and <code>input_c</code>, computes the batch-normalized result for each vector formed in dimension-1 as follows:</p> <p>output = input_b * input_a + input_c</p> <p>where <code>input_b</code> is a precomputed elementwise divide of scale and variance tensors, and <code>input_c</code> is a precomputed elementwise multiply of (-1) * mean and 'input_b' + input bias tensors.</p>"},{"location":"zDNN/#format_40","title":"Format","text":"<pre><code>zdnn_status zdnn_batchnorm(const zdnn_ztensor *input_a,\n                           const zdnn_ztensor *input_b,\n                           const zdnn_ztensor *input_c, zdnn_ztensor *output);\n</code></pre>"},{"location":"zDNN/#parameters_38","title":"Parameters","text":"<ul> <li> <p><code>zdnn_ztensor *input_a</code></p> </li> <li> <p>Must be a 4D ZDNN_NHWC tensor</p> </li> <li> <p>Must follow general tensor requirements</p> </li> <li> <p><code>zdnn_ztensor *input_b</code></p> </li> <li> <p>Must be a 1D ZDNN_1D tensor</p> </li> <li> <p>Must follow general tensor requirements</p> </li> <li> <p><code>zdnn_ztensor *input_c</code></p> </li> <li> <p>Must be a 1D ZDNN_1D tensor</p> </li> <li> <p>Must follow general tensor requirements</p> </li> <li> <p><code>zdnn_ztensor *output</code></p> </li> <li>A zdnn_ztensor of the same size as <code>input_a</code> representing the computed value     of the above formula</li> <li>Must follow general tensor requirements</li> </ul>"},{"location":"zDNN/#returns-see-zdnn-statuses-for-descriptions_12","title":"Returns (see zDNN Statuses for descriptions)","text":"<ul> <li><code>ZDNN_OK</code></li> <li>warning statuses</li> <li><code>ZDNN_INVALID_SHAPE</code></li> <li><code>ZDNN_INVALID_TYPE</code></li> <li><code>ZDNN_INVALID_FORMAT</code></li> <li>hardware statuses</li> </ul>"},{"location":"zDNN/#framework-examples_13","title":"Framework Examples","text":"<p>TensorFlow Batchnorm</p> <p>https://www.tensorflow.org/api_docs/python/tf/keras/layers/BatchNormalization</p> <p>ONNX Batchnorm</p> <p>https://github.com/onnx/onnx/blob/master/docs/Operators.md#BatchNormalization</p>"},{"location":"zDNN/#zdnn_matmul_op","title":"zdnn_matmul_op","text":"<p>Back to Table of Contents</p>"},{"location":"zDNN/#description_41","title":"Description","text":"<p>Given three input zDNN tensors <code>input_a</code>, <code>input_b</code>, and <code>input_c</code>, determine the matrix multiplication of <code>input_a</code> * <code>input_b</code> then perform one of the following operations, using <code>input_c</code> against the dot product, storing the result into the specified <code>output</code> zDNN tensor:</p> <ul> <li>Addition</li> <li>Compare - If dot product is greater than element.</li> <li>Compare - If dot product is greater or equal to element.</li> <li>Compare - If dot product is equal to element.</li> <li>Compare - If dot product is not equal to element.</li> <li>Compare - If dot product is less than or equal to element.</li> <li>Compare - If dot product is less than element.</li> </ul> <p>For an operation type of addition, <code>input_c</code> is added to the intermediate dot product. For operation types of comparison, the intermediate dot product is compared to <code>input_c</code> and if the comparison is true, the result is set to a value of 1; otherwise it is set to a value of 0.</p> <p>The outermost dimension can optionally indicate that the inputs are stacks of matrices. The results for each matrix stack is independent of other stacks but all stacks are calculated in a single call.</p>"},{"location":"zDNN/#format_41","title":"Format","text":"<pre><code>zdnn_status zdnn_matmul_op(const zdnn_ztensor *input_a,\n                           const zdnn_ztensor *input_b,\n                           const zdnn_ztensor *input_c,\n                           zdnn_matmul_ops op_type, zdnn_ztensor *output);\n</code></pre>"},{"location":"zDNN/#input-output-matmul-tensor-requirements","title":"Input / Output matmul tensor requirements","text":"<ul> <li>See table in this section for <code>pre_transformed_desc</code> and shape requirements   for each tensor.</li> <li>All tensors must either be stacked or unstacked.</li> <li>Must follow general tensor requirements</li> </ul> type input_a input_b input_c result unstacked <code>ZDNN_2D</code> (m, n) <code>ZDNN_2D</code> (n, p) <code>ZDNN_1D</code> (p) <code>ZDNN_2D</code> (m, p) stacked <code>ZDNN_3DS</code> (s, m, n) <code>ZDNN_3DS</code> (s, n, p) <code>ZDNN_2DS</code> (s, p) <code>ZDNN_3DS</code> (s, m, p)"},{"location":"zDNN/#parameters_39","title":"Parameters","text":"<ul> <li> <p><code>zdnn_ztensor *input_a</code></p> </li> <li> <p>Input tensor with the first matrix for multiplication</p> </li> <li> <p>pre_transformed shape and layout must match     matmul tensor requirements</p> </li> <li> <p><code>zdnn_ztensor *input_b</code></p> </li> <li> <p>Input tensor with the second matrix for multiplication</p> </li> <li> <p>pre_transformed shape and layout must match     matmul tensor requirements</p> </li> <li> <p><code>zdnn_ztensor *input_c</code></p> </li> <li> <p>Input tensor that will have the requested operation performed against the     intermediate dot product of <code>input_a</code> and <code>input_b</code>.</p> </li> <li> <p>pre_transformed shape and layout must match     matmul tensor requirements</p> </li> <li> <p><code>zdnn_matmul_ops op_type</code></p> </li> <li> <p>Operation to perform on dot product.</p> <ul> <li><code>MATMUL_OP_ADDITION</code></li> <li><code>MATMUL_OP_GREATER</code></li> <li><code>MATMUL_OP_GREATER_EQUAL</code></li> <li><code>MATMUL_OP_EQUAL</code></li> <li><code>MATMUL_OP_NOT_EQUAL</code></li> <li><code>MATMUL_OP_LESSER_EQUAL</code></li> <li><code>MATMUL_OP_LESSER</code></li> </ul> </li> <li> <p><code>zdnn_ztensor *output</code></p> </li> <li>The output tensor which will hold the result of the operation in its buffer.</li> <li>pre_transformed shape and layout must match     matmul tensor requirements</li> </ul>"},{"location":"zDNN/#programming-notes_7","title":"Programming Notes","text":"<ul> <li>Care must be exercised when comparing values for equality or inequality since   the order of operations and rounding may produce, what appear to be, slightly   different values when they are essentially the same value.</li> </ul>"},{"location":"zDNN/#returns-see-zdnn-statuses-for-descriptions_13","title":"Returns (see zDNN Statuses for descriptions)","text":"<ul> <li><code>ZDNN_OK</code></li> <li><code>ZDNN_INVALID_SHAPE</code></li> <li><code>ZDNN_INVALID_TYPE</code></li> <li><code>ZDNN_INVALID_FORMAT</code></li> <li>hardware statuses</li> <li><code>ZDNN_FUNC_RC_F000</code> - Invalid <code>op_type</code>.</li> </ul>"},{"location":"zDNN/#framework-examples_14","title":"Framework Examples","text":"<p>TensorFlow MatMul</p> <p>https://www.tensorflow.org/api_docs/cc/class/tensorflow/ops/mat-mul</p> <p>ONNX MatMul</p>"},{"location":"zDNN/#zdnn_matmul_bcast_op","title":"zdnn_matmul_bcast_op","text":"<p>Back to Table of Contents</p>"},{"location":"zDNN/#description_42","title":"Description","text":"<p>Given three input zDNN tensors <code>input_a</code>, <code>input_b</code>, and <code>input_c</code>, determine the matrix multiplication of <code>input_a</code> * <code>input_b</code>, then perform one of the following operations, using <code>input_c</code> against the dot product, storing the result into the specified <code>output</code> zDNN tensor:</p> <ul> <li>Addition</li> </ul> <p>The outermost dimension for <code>input_a</code> can optionally indicate that the input is a stack of matrices. Each stack of <code>input_a</code> is then multiplied by the same <code>input_b</code> matrix and <code>input_c</code> which are broadcast over each stack of <code>input_a</code>. Results for each stack are returned in the corresponding stack index of <code>output</code>.</p>"},{"location":"zDNN/#format_42","title":"Format","text":"<pre><code>zdnn_status zdnn_matmul_bcast_op(const zdnn_ztensor *input_a,\n                                 const zdnn_ztensor *input_b,\n                                 const zdnn_ztensor *input_c,\n                                 zdnn_matmul_bcast_ops op_type, zdnn_ztensor *output);\n</code></pre>"},{"location":"zDNN/#input-output-matmul-broadcast-tensor-requirements","title":"Input / Output matmul broadcast tensor requirements","text":"<ul> <li>See table in this section for <code>pre_transformed_desc</code> and shape requirements   for each tensor.</li> <li>Must follow general tensor requirements</li> </ul> input_a input_b input_c result <code>ZDNN_3DS</code> (s, m, n) <code>ZDNN_2D</code> (n, p) <code>ZDNN_1D</code> (p) <code>ZDNN_3DS</code> (s, m, p)"},{"location":"zDNN/#parameters_40","title":"Parameters","text":"<ul> <li> <p><code>zdnn_ztensor *input_a</code></p> </li> <li> <p>Input tensor with the first matrix for multiplication.</p> </li> <li> <p>pre_transformed shape and layout must match     matmul broadcast tensor requirements</p> </li> <li> <p><code>zdnn_ztensor *input_b</code></p> </li> <li> <p>Input tensor with the second matrix for multiplication.</p> </li> <li>The same single <code>input_b</code> matrix is broadcast and used as the multiplier for     each stack dimension of <code>input_a</code></li> <li> <p>pre_transformed shape and layout must match     matmul broadcast tensor requirements</p> </li> <li> <p><code>zdnn_ztensor *input_c</code></p> </li> <li> <p>Input tensor that will have the requested operation performed against the     intermediate dot product for each \"m\" dimension in <code>output</code>.</p> </li> <li> <p>pre_transformed shape and layout must match     matmul broadcast tensor requirements</p> </li> <li> <p><code>zdnn_matmul_bcast_ops op_type</code></p> </li> <li> <p>Operation to perform on dot product.</p> <ul> <li><code>MATMUL_BCAST_OP_ADDITION</code></li> </ul> </li> <li> <p><code>zdnn_ztensor *output</code></p> </li> <li>The output tensor which will hold the result of the operation in its buffer.</li> <li>pre_transformed shape and layout must match     matmul broadcast tensor requirements</li> </ul>"},{"location":"zDNN/#programming-notes_8","title":"Programming Notes","text":"<ul> <li><code>zdnn_matmul_bcast_ops</code> only supports <code>MATMUL_BCAST_OP_ADDITION</code> op_type, any   other op_types will be ignored and may not operate compatibly in the future.</li> </ul>"},{"location":"zDNN/#returns-see-zdnn-statuses-for-descriptions_14","title":"Returns (see zDNN Statuses for descriptions)","text":"<ul> <li><code>ZDNN_OK</code></li> <li><code>ZDNN_INVALID_SHAPE</code></li> <li><code>ZDNN_INVALID_TYPE</code></li> <li><code>ZDNN_INVALID_FORMAT</code></li> <li>hardware statuses</li> </ul>"},{"location":"zDNN/#framework-examples_15","title":"Framework Examples","text":"<p>TensorFlow MatMul</p> <p>https://www.tensorflow.org/api_docs/cc/class/tensorflow/ops/mat-mul</p> <p>ONNX MatMul</p>"},{"location":"zDNN/#zdnn_lstm","title":"zdnn_lstm","text":"<p>Back to Table of Contents</p>"},{"location":"zDNN/#description_43","title":"Description","text":"<p>Implements Long-Short Term Memory layer (LSTM - Hochreiter 1997).</p> <p>The following formula is computed for the input tensor input(t) for all time steps:</p> <p>(Default: f=Sigmoid, g=Tanh, h=Tanh):</p> <pre><code>- it = f(Xt*(Wi^T) + Ht-1*(Ri^T) + Wbi + Rbi)\n\n- ft = f(Xt*(Wf^T) + Ht-1*(Rf^T) + Wbf + Rbf)\n\n- ct = g(Xt*(Wc^T) + Ht-1*(Rc^T) + Wbc + Rbc)\n\n- Ct = ft (.) Ct-1 + it (.) ct\n\n- ot = f(Xt*(Wo^T) + Ht-1*(Ro^T) + Wbo + Rbo)\n\n- Ht = ot (.) h(Ct)\n</code></pre>"},{"location":"zDNN/#format_43","title":"Format","text":"<pre><code>zdnn_status zdnn_lstm(const zdnn_ztensor *input, const zdnn_ztensor *h0,\n                      const zdnn_ztensor *c0, const zdnn_ztensor *weights,\n                      const zdnn_ztensor *biases,\n                      const zdnn_ztensor *hidden_weights,\n                      const zdnn_ztensor *hidden_biases,\n                      lstm_gru_direction direction, void *work_area,\n                      zdnn_ztensor *hn_output, zdnn_ztensor *cf_output);\n</code></pre> <p>Also see an example in the usage example section.</p>"},{"location":"zDNN/#lstm-input-output-requirements","title":"LSTM Input / Output requirements","text":"<ul> <li><code>num_hidden</code> dimensions: </li> <li>Any num_hidden dimension must be less than or equal to 8192 elements.</li> </ul>"},{"location":"zDNN/#parameters_41","title":"Parameters","text":"<ul> <li> <p><code>zdnn_ztensor *input</code></p> </li> <li> <p>Input must be a tensor with the shape (num_timesteps, num_batches,     num_features) prior to transformation with the <code>zdnn_transform_ztensor</code> API.</p> </li> <li>Expects <code>pre_transformed_desc-&gt;layout</code> to be <code>ZDNN_3DS</code>.</li> <li> <p>Must follow general tensor requirements</p> </li> <li> <p><code>zdnn_ztensor *h0</code></p> </li> <li> <p>Tensor containing the initial hidden state with shape (num_dirs,     num_batches, num_hidden) prior to transformation with the     <code>zdnn_transform_ztensor</code> API.</p> </li> <li>Expects <code>pre_transformed_desc-&gt;layout</code> to be <code>ZDNN_3DS</code>.</li> <li>Must follow general tensor requirements</li> <li> <p>Must follow num_hidden requirements</p> </li> <li> <p><code>zdnn_ztensor *c0</code></p> </li> <li> <p>Tensor containing the initial cell state with shape (num_dirs, num_batches,     num_hidden) prior to transformation with the <code>zdnn_transform_ztensor</code> API.</p> </li> <li>Expects <code>pre_transformed_desc-&gt;layout</code> to be <code>ZDNN_3DS</code>.</li> <li>Must follow general tensor requirements</li> <li> <p>Must follow num_hidden requirements</p> </li> <li> <p><code>zdnn_ztensor *weights</code></p> </li> <li> <p>Tensor containing the concatenated input connection weights in Forget,     Input, Cell, Output (FICO) order.</p> </li> <li>Prior to transformation, each gate needs to be transposed to shape     (num_dirs, num_features, num_hidden) by the caller.</li> <li>Expects <code>pre_transformed_desc-&gt;layout</code> to be <code>ZDNN_3DS</code>.</li> <li>Expects <code>zdnn_concat_info</code> having the following flags turned on:<ul> <li><code>RNN_TYPE_LSTM</code></li> <li><code>USAGE_WEIGHTS</code></li> <li>Appropriate <code>PREV_LAYER</code> flag:</li> <li><code>PREV_LAYER_NONE</code> if <code>input</code> tensor is not from a previous RNN layer</li> <li><code>PREV_LAYER_UNI</code> if <code>input</code> tensor is uni-directional output from a     previous RNN layer</li> <li><code>PREV_LAYER_BIDIR</code> if <code>input</code> tensor is bi-directional output from a     previous RNN layer</li> </ul> </li> <li>Must follow concatenated tensor requirements</li> <li> <p>Must follow num_hidden requirements</p> </li> <li> <p><code>zdnn_ztensor *biases</code></p> </li> <li> <p>Tensor containing the concatenated input connection bias in Forget, Input,     Cell, Output (FICO) order.</p> </li> <li>Prior to transformation, expects each gate needs to be shape (num_dirs,     num_hidden).</li> <li>Expects <code>pre_transformed_desc-&gt;layout</code> to be <code>ZDNN_2DS</code>.</li> <li>Expects <code>zdnn_concat_info</code> having the following flags turned on:<ul> <li><code>RNN_TYPE_LSTM</code></li> <li><code>USAGE_HIDDEN_WEIGHTS</code></li> <li>Appropriate <code>PREV_LAYER</code> flag:</li> <li><code>PREV_LAYER_NONE</code> if <code>input</code> tensor is not from a previous RNN layer</li> <li><code>PREV_LAYER_UNI</code> if <code>input</code> tensor is uni-directional output from a     previous RNN layer</li> <li><code>PREV_LAYER_BIDIR</code> if <code>input</code> tensor is bi-directional output from a     previous RNN layer</li> </ul> </li> <li>Must follow concatenated tensor requirements</li> <li> <p>Must follow num_hidden requirements</p> </li> <li> <p><code>zdnn_ztensor *hidden_weights</code></p> </li> <li> <p>Tensor containing the concatenated hidden connection weights in Forget,     Input, Cell, Output (FICO) order.</p> </li> <li>Prior to transformation, each gate needs to be transposed to shape     (num_dirs, num_hidden, num_hidden) by the caller.</li> <li>Expects <code>pre_transformed_desc-&gt;layout</code> to be <code>ZDNN_3DS</code>.</li> <li>Expects <code>zdnn_concat_info</code> having the following flags turned on:<ul> <li><code>RNN_TYPE_LSTM</code></li> <li><code>USAGE_BIASES</code></li> <li>Appropriate <code>PREV_LAYER</code> flag:</li> <li><code>PREV_LAYER_NONE</code> if <code>input</code> tensor is not from a previous RNN layer</li> <li><code>PREV_LAYER_UNI</code> if <code>input</code> tensor is uni-directional output from a     previous RNN layer</li> <li><code>PREV_LAYER_BIDIR</code> if <code>input</code> tensor is bi-directional output from a     previous RNN layer</li> </ul> </li> <li>Must follow concatenated tensor requirements</li> <li> <p>Must follow num_hidden requirements</p> </li> <li> <p><code>zdnn_ztensor *hidden_biases</code></p> </li> <li> <p>Tensor containing the concatenated hidden connection bias in Forget, Input,     Cell, Output (FICO) order.</p> </li> <li>Prior to transformation, expects each gate needs to be shape (num_dirs,     num_hidden).</li> <li>Expects <code>pre_transformed_desc-&gt;layout</code> to be <code>ZDNN_2DS</code>.</li> <li>Expects <code>zdnn_concat_info</code> having the following flags turned on:<ul> <li><code>RNN_TYPE_LSTM</code></li> <li><code>USAGE_HIDDEN_BIASES</code></li> <li>Appropriate <code>PREV_LAYER</code> flag:</li> <li><code>PREV_LAYER_NONE</code> if <code>input</code> tensor is not from a previous RNN layer</li> <li><code>PREV_LAYER_UNI</code> if <code>input</code> tensor is uni-directional output from a     previous RNN layer</li> <li><code>PREV_LAYER_BIDIR</code> if <code>input</code> tensor is bi-directional output from a     previous RNN layer</li> </ul> </li> <li>Must follow concatenated tensor requirements</li> <li> <p>Must follow num_hidden requirements</p> </li> <li> <p><code>lstm_gru_direction direction</code></p> </li> <li> <p>Direction indicator of <code>lstm_gru_direction direction</code> type. Valid values:</p> <ul> <li><code>FWD</code> (forward)</li> <li><code>BWD</code> (backward)</li> <li><code>BIDIR</code> (bi-directional).</li> </ul> </li> <li> <p>For input and output shapes, the num_dirs dimension should be:</p> <ul> <li><code>1</code> for unidirectional calls such as FWD or BWD</li> <li><code>2</code> for bidirectional calls such that:</li> <li>dimension 0 contains FWD values.</li> <li>dimension 1 contains BWD values.</li> </ul> </li> <li> <p><code>void *work_area</code></p> </li> <li> <p>A preallocated memory address to use for temporary storage during internal     operation processing.</p> </li> <li>If set to NULL, the operation will determine, allocate and free storage     automatically.</li> <li> <p>Amount of required storage can be determined given the LSTM timestep, batch,     and num_hidden values.</p> <ul> <li>The sample code below creates a ztensor descriptor that is an equivalent   size of the required <code>work_area</code>. To use this sample code yourself,   replace the <code>num_timesteps</code>, <code>num_batches</code>, and <code>num_hidden</code> variables   with your own values.</li> </ul> <pre><code>  zdnn_tensor_desc desc;\n  desc.dim4 = (4 * num_timesteps) + 6;\n  desc.dim3 = 1;\n  desc.dim2 = num_batches;\n  desc.dim1 = num_hidden;\n  uint64_t work_area_size = zdnn_getsize_ztensor(&amp;desc);\n</code></pre> </li> <li> <p>For bidirectional, twice the amount of contiguous storage is required.</p> </li> <li> <p>The start of the buffer must be 4k aligned.</p> </li> <li> <p><code>zdnn_ztensor *hn_output</code></p> </li> <li> <p>Output results of the hidden states</p> </li> <li> <p>Expects pre_transformed_desc-&gt;layout to be <code>ZDNN_4DS</code>.</p> </li> <li> <p>Must follow general tensor requirements</p> </li> <li> <p>Must follow num_hidden requirements</p> </li> <li> <p>Output pre-transformed shapes:</p> <ul> <li>all timesteps: (num_timesteps, num_dirs, num_batches, num_hidden)</li> <li>final timestep only: (1, num_dirs, num_batches, num_hidden)</li> </ul> </li> <li> <p>For bidirectional (<code>BIDIR</code>) output:</p> <ul> <li>Forward and backward results are concatenated on the innermost dimension.</li> <li>Can be used directly as input for subsequent RNN layers without needing   untransformation.</li> <li>Can not be used directly as input for other non-RNN zDNN ops.</li> <li>Untransformation is supported.</li> </ul> </li> <li> <p>Note that for <code>BWD</code> and the backward component of <code>BIDIR</code> directions, the     output order matches the order of the input, not the processing order. For     example, the first input timestep is the last to be processed and its result     is the first timestep of the output.</p> </li> <li> <p><code>zdnn_ztensor *cf_output</code></p> </li> <li> <p>Output results of the cell state for the last processed timestep</p> </li> <li> <p>Expects pre_transformed_desc-&gt;layout to be <code>ZDNN_4DS</code>.</p> </li> <li> <p>Must follow general tensor requirements</p> </li> <li> <p>Must follow num_hidden requirements</p> </li> <li> <p>Output pre-transformed shapes:</p> <ul> <li>(1, num_dirs, num_batches, num_hidden)</li> </ul> </li> <li> <p>For bidirectional (<code>BIDIR</code>):</p> <ul> <li>Forward and backward results are concatenated on the innermost dimension.</li> <li>Can not be used directly as input for other non-RNN zDNN ops.</li> <li>Untransformation is supported.</li> </ul> </li> </ul>"},{"location":"zDNN/#summary","title":"Summary","text":"pre-transformed layout pre-transformed shape input <code>ZDNN_3DS</code> (num_timesteps, num_batches, num_features) h0 <code>ZDNN_3DS</code> (num_dirs, num_batches, num_hidden) c0 <code>ZDNN_3DS</code> (num_dirs, num_batches, num_hidden) weights <code>ZDNN_3DS</code> (num_dirs, num_features, num_hidden) bias <code>ZDNN_2DS</code> (num_dirs, num_hidden) hidden_weights <code>ZDNN_3DS</code> (num_dirs, num_hidden, num_hidden) hidden_biases <code>ZDNN_2DS</code> (num_dirs, num_hidden) hn_output <code>ZDNN_4DS</code> (num_timesteps, num_dirs, num_batches, num_hidden)(last timestep only when <code>num_timesteps</code> = 1) cf_output <code>ZDNN_4DS</code> (1, num_dirs, num_batches, num_hidden) create transformed descriptor via input <code>zdnn_generate_transformed_desc</code> h0 <code>zdnn_generate_transformed_desc</code> c0 <code>zdnn_generate_transformed_desc</code> weights <code>zdnn_generate_transformed_desc_concatenated</code> - <code>RNN_TYPE_LSTM</code> + <code>USAGE_WEIGHTS</code> + one of the following:<code>PREV_LAYER_NONE</code>/<code>PREV_LAYER_UNI</code>/<code>PREV_LAYER_BIDIR</code> bias <code>zdnn_generate_transformed_desc_concatenated</code> - <code>RNN_TYPE_LSTM</code> + <code>USAGE_BIASES</code> + one of the following:<code>PREV_LAYER_NONE</code>/<code>PREV_LAYER_UNI</code>/<code>PREV_LAYER_BIDIR</code> hidden_weights <code>zdnn_generate_transformed_desc_concatenated</code> - <code>RNN_TYPE_LSTM</code> + <code>USAGE_HIDDEN_WEIGHTS</code> + one of the following:<code>PREV_LAYER_NONE</code>/<code>PREV_LAYER_UNI</code>/<code>PREV_LAYER_BIDIR</code> hidden_biases <code>zdnn_generate_transformed_desc_concatenated</code> - <code>RNN_TYPE_LSTM</code> + <code>USAGE_HIDDEN_BIASES</code> + one of the following:<code>PREV_LAYER_NONE</code>/<code>PREV_LAYER_UNI</code>/<code>PREV_LAYER_BIDIR</code> hn_output <code>zdnn_generate_transformed_desc</code> cf_output <code>zdnn_generate_transformed_desc</code>"},{"location":"zDNN/#returns-see-zdnn-statuses-for-descriptions_15","title":"Returns (see zDNN Statuses for descriptions)","text":"<ul> <li><code>ZDNN_OK</code></li> <li><code>ZDNN_INVALID_TYPE</code></li> <li><code>ZDNN_INVALID_FORMAT</code></li> <li><code>ZDNN_INVALID_SHAPE</code> - (if any of the following are not true)</li> <li><code>hn_output</code> timesteps dimension must be 1 or the same size as <code>input</code>     timestep dimension.</li> <li>All tensors with a direction dimension have the same direction dimension     size.</li> <li><code>input</code> timestep dimension must be greater than or equal to 1.</li> <li>Other general shape violations (exceeds MDIS, etc.)</li> <li><code>ZDNN_INVALID_DIRECTION</code> - <code>direction</code> parameter was not a recognized   <code>lstm_gru_direction</code>.</li> <li><code>ZDNN_ALLOCATION_FAILURE</code> - A preallocated <code>work_area</code> was not specified and   internal allocation for the required memory failed.</li> <li>hardware statuses</li> </ul>"},{"location":"zDNN/#framework-examples_16","title":"Framework Examples","text":"<p>TensorFlow LSTM</p> <p>https://www.tensorflow.org/api_docs/python/tf/keras/layers/LSTMCell</p> <p>ONNX LSTM</p>"},{"location":"zDNN/#zdnn_gru","title":"zdnn_gru","text":"<p>Back to Table of Contents</p>"},{"location":"zDNN/#description_44","title":"Description","text":"<p>Implements Gated Recurrent Unit (Kyunghyun Cho 2014). Supports only reset after linear.</p> <p>The following formula is computed for the input tensor input(t) for all time steps:</p> <pre><code>(Default: f=Sigmoid, g=Tanh):\n\n- zt = f(Xt*(Wz^T) + Ht-1*(Rz^T) + Wbz + Rbz)\n\n- rt = f(Xt*(Wr^T) + Ht-1*(Rr^T) + Wbr + Rbr)\n\n- ht = g(Xt*(Wh^T) + (rt (.) (Ht-1*(Rh^T) + Rbh)) + Wbh)\n\n- Ht = (1 - zt) (.) ht + zt (.) Ht-1\n</code></pre>"},{"location":"zDNN/#format_44","title":"Format","text":"<pre><code>zdnn_status zdnn_gru(const zdnn_ztensor *input, const zdnn_ztensor *h0,\n                     const zdnn_ztensor *weights, const zdnn_ztensor *biases,\n                     const zdnn_ztensor *hidden_weights,\n                     const zdnn_ztensor *hidden_biases,\n                     lstm_gru_direction direction, void *work_area,\n                     zdnn_ztensor *hn_output);\n</code></pre> <p>Also see an example in the usage example section.</p>"},{"location":"zDNN/#gru-input-output-requirements","title":"GRU Input / Output requirements","text":"<ul> <li><code>num_hidden</code> dimensions: </li> <li>Any num_hidden dimension must be less than or equal to 10880 elements.</li> </ul>"},{"location":"zDNN/#parameters_42","title":"Parameters","text":"<ul> <li> <p><code>zdnn_ztensor *input</code></p> </li> <li> <p>Input must be a tensor with the shape (num_timesteps, num_batches,     num_features) prior to transformation with the <code>zdnn_transform_ztensor</code> API.</p> </li> <li>Expects <code>pre_transformed_desc-&gt;layout</code> to be <code>ZDNN_3DS</code>.</li> <li> <p>Must follow general tensor requirements</p> </li> <li> <p><code>zdnn_ztensor *h0</code></p> </li> <li> <p>Tensor containing the initial hidden state with shape (num_dirs,     num_batches, num_hidden) prior to transformation with the     <code>zdnn_transform_ztensor</code> API.</p> </li> <li>Expects <code>pre_transformed_desc-&gt;layout</code> to be <code>ZDNN_3DS</code>.</li> <li>Must follow general tensor requirements</li> <li> <p>Must follow num_hidden requirements</p> </li> <li> <p><code>zdnn_ztensor *weights</code></p> </li> <li> <p>Tensor containing the concatenated input connection weights in (Z)update,     Reset, Hidden, (ZRH) order.</p> </li> <li>Prior to transformation, each gate needs to be transposed to shape     (num_dirs, num_features, num_hidden) by the caller.</li> <li>Expects <code>pre_transformed_desc-&gt;layout</code> to be <code>ZDNN_3DS</code>.</li> <li>Expects <code>zdnn_concat_info</code> having the following flags turned on:<ul> <li><code>RNN_TYPE_GRU</code></li> <li><code>USAGE_WEIGHTS</code></li> <li>Appropriate <code>PREV_LAYER</code> flag:</li> <li><code>PREV_LAYER_NONE</code> if <code>input</code> tensor is not from a previous RNN layer</li> <li><code>PREV_LAYER_UNI</code> if <code>input</code> tensor is uni-directional output from a     previous RNN layer</li> <li><code>PREV_LAYER_BIDIR</code> if <code>input</code> tensor is bi-directional output from a     previous RNN layer</li> </ul> </li> <li>Must follow concatenated tensor requirements</li> <li> <p>Must follow num_hidden requirements</p> </li> <li> <p><code>zdnn_ztensor *biases</code></p> </li> <li> <p>Tensor containing the concatenated input connection bias in (Z)update,     Reset, Hidden, (ZRH) order.</p> </li> <li>Prior to transformation, expects each gate needs to be shape (num_dirs,     num_hidden).</li> <li>Expects <code>pre_transformed_desc-&gt;layout</code> to be <code>ZDNN_2DS</code>.</li> <li>Expects <code>zdnn_concat_info</code> having the following flags turned on:<ul> <li><code>RNN_TYPE_GRU</code></li> <li><code>USAGE_HIDDEN_WEIGHTS</code></li> <li>Appropriate <code>PREV_LAYER</code> flag:</li> <li><code>PREV_LAYER_NONE</code> if <code>input</code> tensor is not from a previous RNN layer</li> <li><code>PREV_LAYER_UNI</code> if <code>input</code> tensor is uni-directional output from a     previous RNN layer</li> <li><code>PREV_LAYER_BIDIR</code> if <code>input</code> tensor is bi-directional output from a     previous RNN layer</li> </ul> </li> <li>Must follow concatenated tensor requirements</li> <li> <p>Must follow num_hidden requirements</p> </li> <li> <p><code>zdnn_ztensor *hidden_weights</code></p> </li> <li> <p>Tensor containing the concatenated hidden connection weights in (Z)update,     Reset, Hidden, (ZRH) order.</p> </li> <li>Prior to transformation, each gate needs to be transposed to shape     (num_dirs, num_hidden, num_hidden) by the caller.</li> <li>Expects <code>pre_transformed_desc-&gt;layout</code> to be <code>ZDNN_3DS</code>.</li> <li>Expects <code>zdnn_concat_info</code> having the following flags turned on:<ul> <li><code>RNN_TYPE_GRU</code></li> <li><code>USAGE_BIASES</code></li> <li>Appropriate <code>PREV_LAYER</code> flag:</li> <li><code>PREV_LAYER_NONE</code> if <code>input</code> tensor is not from a previous RNN layer</li> <li><code>PREV_LAYER_UNI</code> if <code>input</code> tensor is uni-directional output from a     previous RNN layer</li> <li><code>PREV_LAYER_BIDIR</code> if <code>input</code> tensor is bi-directional output from a     previous RNN layer</li> </ul> </li> <li>Must follow concatenated tensor requirements</li> <li> <p>Must follow num_hidden requirements</p> </li> <li> <p><code>zdnn_ztensor *hidden_biases</code></p> </li> <li> <p>Tensor containing the concatenated hidden connection bias in (Z)update,     Reset, Hidden, (ZRH) order.</p> </li> <li>Prior to transformation, expects each gate needs to be shape (num_dirs,     num_hidden).</li> <li>Expects <code>pre_transformed_desc-&gt;layout</code> to be <code>ZDNN_2DS</code>.</li> <li>Expects <code>zdnn_concat_info</code> having the following flags turned on:<ul> <li><code>RNN_TYPE_GRU</code></li> <li><code>USAGE_HIDDEN_BIASES</code></li> <li>Appropriate <code>PREV_LAYER</code> flag:</li> <li><code>PREV_LAYER_NONE</code> if <code>input</code> tensor is not from a previous RNN layer</li> <li><code>PREV_LAYER_UNI</code> if <code>input</code> tensor is uni-directional output from a     previous RNN layer</li> <li><code>PREV_LAYER_BIDIR</code> if <code>input</code> tensor is bi-directional output from a     previous RNN layer</li> </ul> </li> <li>Must follow concatenated tensor requirements</li> <li> <p>Must follow num_hidden requirements</p> </li> <li> <p><code>lstm_gru_direction direction</code></p> </li> <li> <p>Direction indicator of <code>lstm_gru_direction direction</code> type. Valid values:</p> <ul> <li><code>FWD</code> (forward)</li> <li><code>BWD</code> (backward)</li> <li><code>BIDIR</code> (bi-directional).</li> </ul> </li> <li> <p>For input shapes, the num_dirs dimension should be:</p> <ul> <li><code>1</code> for unidirectional calls such as FWD or BWD</li> <li><code>2</code> for bidirectional calls such that:</li> <li>dimension 0 contains FWD values.</li> <li>dimension 1 contains BWD values.</li> </ul> </li> <li> <p><code>void *work_area</code></p> </li> <li> <p>A preallocated memory address to use for temporary storage during internal     operation processing.</p> </li> <li>If set to NULL, the operation will determine, allocate and free storage     automatically.</li> <li> <p>Amount of required storage can be determined given the GRU timestep, batch,     and num_hidden values.</p> <ul> <li>The sample code below creates a ztensor descriptor that is an equivalent   size of the required <code>work_area</code>. To use this sample code yourself,   replace the <code>num_timesteps</code>, <code>num_batches</code>, and <code>num_hidden</code> variables   with your own values.</li> </ul> <pre><code>  zdnn_tensor_desc desc;\n  desc.dim4 = (3 * num_timesteps) + 5;\n  desc.dim3 = 1;\n  desc.dim2 = num_batches;\n  desc.dim1 = num_hidden;\n  uint64_t work_area_size = zdnn_getsize_ztensor(&amp;desc);\n</code></pre> </li> <li> <p>For bidirectional, twice the amount of contiguous storage is required.</p> </li> <li> <p>The start of the buffer must be 4k aligned.</p> </li> <li> <p><code>zdnn_ztensor *hn_output</code></p> </li> <li> <p>Output results of the hidden states</p> </li> <li> <p>Expects pre_transformed_desc-&gt;layout to be <code>ZDNN_4DS</code>.</p> </li> <li> <p>Must follow general tensor requirements</p> </li> <li> <p>Must follow num_hidden requirements</p> </li> <li> <p>Output pre-transformed shapes:</p> <ul> <li>all timesteps: (num_timesteps, num_dirs, num_batches, num_hidden)</li> <li>final timestep only: (1, num_dirs, num_batches, num_hidden)</li> </ul> </li> <li> <p>For bidirectional (<code>BIDIR</code>) output:</p> <ul> <li>Forward and backward results are concatenated on the innermost dimension.</li> <li>Can be used directly as input for subsequent RNN layers without needing   untransformation.</li> <li>Can not be used directly as input for other non-RNN zDNN ops.</li> <li>Untransformation is supported.</li> </ul> </li> <li> <p>Note that for <code>BWD</code> and the backward component of <code>BIDIR</code> directions, the     output order matches the order of the input, not the processing order. For     example, the first input timestep is the last to be processed and its result     is the first timestep of the output.</p> </li> </ul>"},{"location":"zDNN/#summary_1","title":"Summary","text":"pre-transformed layout pre-transformed shape input <code>ZDNN_3DS</code> (num_timesteps, num_batches, num_features) h0 <code>ZDNN_3DS</code> (num_dirs, num_batches, num_hidden) c0 <code>ZDNN_3DS</code> (num_dirs, num_batches, num_hidden) weights <code>ZDNN_3DS</code> (num_dirs, num_features, num_hidden) bias <code>ZDNN_2DS</code> (num_dirs, num_hidden) hidden_weights <code>ZDNN_3DS</code> (num_dirs, num_hidden, num_hidden) hidden_biases <code>ZDNN_2DS</code> (num_dirs, num_hidden) hn_output <code>ZDNN_4DS</code> (num_timesteps, num_dirs, num_batches, num_hidden)(last timestep only when <code>num_timesteps</code> = 1) create transformed descriptor via input <code>zdnn_generate_transformed_desc</code> h0 <code>zdnn_generate_transformed_desc</code> c0 <code>zdnn_generate_transformed_desc</code> weights <code>zdnn_generate_transformed_desc_concatenated</code> - <code>RNN_TYPE_LSTM</code> + <code>USAGE_WEIGHTS</code> + one of the following:<code>PREV_LAYER_NONE</code>/<code>PREV_LAYER_UNI</code>/<code>PREV_LAYER_BIDIR</code> bias <code>zdnn_generate_transformed_desc_concatenated</code> - <code>RNN_TYPE_LSTM</code> + <code>USAGE_BIASES</code> + one of the following:<code>PREV_LAYER_NONE</code>/<code>PREV_LAYER_UNI</code>/<code>PREV_LAYER_BIDIR</code> hidden_weights <code>zdnn_generate_transformed_desc_concatenated</code> - <code>RNN_TYPE_LSTM</code> + <code>USAGE_HIDDEN_WEIGHTS</code> + one of the following:<code>PREV_LAYER_NONE</code>/<code>PREV_LAYER_UNI</code>/<code>PREV_LAYER_BIDIR</code> hidden_biases <code>zdnn_generate_transformed_desc_concatenated</code> - <code>RNN_TYPE_LSTM</code> + <code>USAGE_HIDDEN_BIASES</code> + one of the following:<code>PREV_LAYER_NONE</code>/<code>PREV_LAYER_UNI</code>/<code>PREV_LAYER_BIDIR</code> hn_output <code>zdnn_generate_transformed_desc</code>"},{"location":"zDNN/#returns-see-zdnn-statuses-for-descriptions_16","title":"Returns (see zDNN Statuses for descriptions)","text":"<ul> <li><code>ZDNN_OK</code></li> <li><code>ZDNN_INVALID_TYPE</code></li> <li><code>ZDNN_INVALID_FORMAT</code></li> <li><code>ZDNN_INVALID_SHAPE</code> - (if any of the following are not true)</li> <li><code>hn_output</code> timesteps dimension must be 1 or the same size as <code>input</code>     timestep dimension.</li> <li>All tensors with a direction dimension have the same direction dimension     size.</li> <li><code>input</code> timestep dimension must be greater than or equal to 1.</li> <li>Other general shape violations (exceeds MDIS, etc.)</li> <li><code>ZDNN_INVALID_DIRECTION</code> - <code>direction</code> parameter was not a recognized   <code>lstm_gru_direction</code>.</li> <li><code>ZDNN_ALLOCATION_FAILURE</code> - A preallocated <code>work_area</code> was not specified and   internal allocation for the required memory failed.</li> <li>hardware statuses</li> </ul>"},{"location":"zDNN/#framework-examples_17","title":"Framework Examples","text":"<p>TensorFlow GRU</p> <p>https://www.tensorflow.org/api_docs/python/tf/keras/layers/GRUCell</p> <p>ONNX GRU</p>"},{"location":"zDNN/#zdnn_avgpool2d","title":"zdnn_avgpool2d","text":"<p>Back to Table of Contents</p>"},{"location":"zDNN/#description_45","title":"Description","text":"<p>Given an input tensor in zDNN transformed format, padding type, kernel size and kernel stride, produces a downsampled tensor reducing the middle dimensions based on the mean values within the kernel window at each step and stores the results into the provided output zDNN tensor.</p>"},{"location":"zDNN/#format_45","title":"Format","text":"<pre><code>zdnn_status zdnn_avgpool2d(const zdnn_ztensor *input,\n                           zdnn_pool_padding padding_type,\n                           uint32_t kernel_height, uint32_t kernel_width,\n                           uint32_t stride_height, uint32_t stride_width,\n                           zdnn_ztensor *output);\n</code></pre>"},{"location":"zDNN/#parameters_43","title":"Parameters","text":"<ul> <li> <p><code>zdnn_ztensor *input</code></p> </li> <li> <p>Tensor with original values to be downsampled in the output tensor.</p> </li> <li>Must be a ZDNN_NHWC tensor with pre_transformed shape     [batch_Num, Height, Width, Channel].</li> <li>See Parameter Restrictions below for     information on the expected shape of the input tensor.</li> <li> <p>Must follow general tensor requirements</p> </li> <li> <p><code>padding_type</code></p> </li> <li> <p>The type of padding to use for the pooling operations.</p> </li> <li>Valid values: are <code>SAME_PADDING</code> or <code>VALID_PADDING</code>.</li> <li>See Parameter Restrictions below for     information on the expected value of padding_type.</li> <li> <p>For information on \"same\" vs \"valid\" padding see:     https://www.pico.net/kb/what-is-the-difference-between-same-and-valid-padding-in-tf-nn-max-pool-of-tensorflow.</p> </li> <li> <p><code>kernel_height</code></p> </li> <li> <p>Size of the kernel window that passes over the input's height dimension.</p> </li> <li> <p>See Parameter Restrictions below for     information on the expected value of kerneL_height.</p> </li> <li> <p><code>kernel_width</code></p> </li> <li> <p>Size of the kernel window that passes over the input's width dimension.</p> </li> <li> <p>See Parameter Restrictions below for     information on the expected value of kerneL_width.</p> </li> <li> <p><code>stride_height</code></p> </li> <li> <p>Number of positions the kernel moves over input's height dimension at each     step.</p> </li> <li>If <code>stride_height</code> is 0 then <code>stride_width</code> must also be 0.</li> <li> <p>If strides are greater than 0 then <code>stride_height</code> must be less than or     equal to 30.</p> </li> <li> <p><code>stride_width</code></p> </li> <li> <p>Number of positions the kernel moves over the input's width dimension at     each step.</p> </li> <li>If <code>stride_height</code> is 0 then <code>stride_width</code> must also be 0.</li> <li> <p>If strides are greater than 0 then <code>stride_width</code> must be less than or equal     to 30.</p> </li> <li> <p><code>zdnn_ztensor *output</code></p> </li> <li>The result tensor which will hold the result of the pooling operation its     buffer.</li> <li>Must be a ZDNN_NHWC tensor with pre_transformed shape     [batch_Num, Height, Width, Channel].</li> <li>See Parameter Restrictions below for     information on the expected shape of the output tensor.</li> <li>Must follow general tensor requirements</li> </ul>"},{"location":"zDNN/#avgpool2d-parameter-restrictions","title":"AvgPool2D Parameter Restrictions","text":"<p>Parameter restrictions may vary based on provided strides and padding_type.</p> <ul> <li> <p>Input tensor batch_Num and Channel dimensions must always match the output   tensor's respective dimensions.</p> </li> <li> <p>If strides are 0:</p> </li> <li>Both input tensor's Height dimension and the kernel_height must match and be     less than or equal to 1024.</li> <li>Both input tensor's Width dimension and the kernel_width must match and be     less than or equal to 1024.</li> <li>Output tensor's height and width dimensions must be 1.</li> <li>padding_type must be <code>VALID_PADDING</code>.</li> <li>If strides are greater than zero:</li> <li>kernel_width and kernel_height must be less than or equal to 64.</li> <li>input tensor's height or weight dimension must not be greater than 1024.</li> <li>If padding_type is <code>SAME_PADDING</code>:<ul> <li>Output tensor's height dimension must equal   <code>ceil((float)input's height / stride_height)</code>.</li> <li>Output tensor's width dimension must equal   <code>ceil((float)input's width / stride_width)</code>.</li> </ul> </li> <li>If padding_type is <code>VALID_PADDING</code>:<ul> <li>Output tensor's height dimension must equal   <code>ceil((float)(input's height - kernel_height + 1) / stride_height)</code>.</li> <li>Output tensor's width dimension must equal   <code>ceil((float)(input's width - kernel_width + 1) / stride_width)</code>.</li> </ul> </li> </ul>"},{"location":"zDNN/#programming-notes_9","title":"Programming Notes","text":"<ul> <li>If the magnitude of difference between elements of <code>input</code> is large (greater   than 10), accuracy may be reduced.</li> </ul>"},{"location":"zDNN/#returns-see-zdnn-statuses-for-descriptions_17","title":"Returns (see zDNN Statuses for descriptions)","text":"<ul> <li><code>ZDNN_OK</code></li> <li><code>ZDNN_INVALID_SHAPE</code></li> <li>Shape of input or output tensor is invalid based on given kernel and stride     parameters</li> <li>Other general shape violations (exceeds MDIS, etc.)</li> <li><code>ZDNN_INVALID_TYPE</code></li> <li><code>ZDNN_INVALID_FORMAT</code></li> <li><code>ZDNN_INVALID_STRIDE_PADDING</code></li> <li><code>ZDNN_INVALID_STRIDES</code> - One stride was non-zero, but not the other.</li> <li>hardware statuses</li> <li><code>ZDNN_EXCEEDS_MDIS</code> will also occur if any of the following conditions     occur:<ul> <li>stride_height is larger than <code>zdnn_get_nnpa_max_dim_idx_size</code>.</li> <li>stride_width is larger than <code>zdnn_get_nnpa_max_dim_idx_size</code>.</li> <li>kernel_height is 0 or is larger than <code>zdnn_get_nnpa_max_dim_idx_size</code>.</li> <li>kernel_width is 0 or is larger than <code>zdnn_get_nnpa_max_dim_idx_size</code>.</li> </ul> </li> <li><code>ZDNN_FUNC_RC_F000</code> - Invalid <code>padding_type</code></li> <li><code>ZDNN_FUNC_RC_F001</code> - <code>stride_height</code> = 0 and <code>stride_width</code> = 0, but a     kernel parameter is greater than allowed (see <code>kernel_height</code> or     <code>kernel_width</code> above)</li> <li><code>ZDNN_FUNC_RC_F002</code> - <code>stride_height</code> &gt; 0 and <code>stride_width</code> &gt; 0, but a     kernel parameter is greater than allowed (see <code>kernel_height</code> or     <code>kernel_width</code> above)</li> <li><code>ZDNN_FUNC_RC_F003</code> - <code>stride_height</code> &gt; 0 and <code>stride_width</code> &gt; 0, but a     stride parameter is greater than allowed (see <code>stride_height</code> or     <code>stride_width</code> above)</li> <li><code>ZDNN_FUNC_RC_F004</code> - <code>stride_height</code> &gt; 0 and <code>stride_width</code> &gt; 0, but either     input tensor's height or weight dimension is greater than 1024.</li> </ul>"},{"location":"zDNN/#framework-examples_18","title":"Framework Examples","text":"<p>TensorFlow AvgPool</p> <p>https://www.tensorflow.org/api_docs/cc/class/tensorflow/ops/avg-pool</p> <p>ONNX AvgPool</p> <p>https://github.com/onnx/onnx/blob/master/docs/Operators.md#AveragePool</p>"},{"location":"zDNN/#zdnn_maxpool2d","title":"zdnn_maxpool2d","text":"<p>Back to Table of Contents</p>"},{"location":"zDNN/#description_46","title":"Description","text":"<p>Given an input tensor in zDNN transformed format, padding type, kernel size and kernel stride, produces a downsampled tensor reducing the middle dimensions based on the maximum values within the kernel window at each step and stores the results into the provided output zDNN tensor.</p>"},{"location":"zDNN/#format_46","title":"Format","text":"<pre><code>zdnn_status zdnn_maxpool2d(const zdnn_ztensor *input,\n                           zdnn_pool_padding padding_type,\n                           uint32_t kernel_height, uint32_t kernel_width,\n                           uint32_t stride_height, uint32_t stride_width,\n                           zdnn_ztensor *output);\n</code></pre>"},{"location":"zDNN/#parameters_44","title":"Parameters","text":"<ul> <li> <p><code>zdnn_ztensor *input</code></p> </li> <li> <p>Tensor with original values to be downsampled in the output tensor.</p> </li> <li>Must be a ZDNN_NHWC tensor with pre_transformed shape     [batch_Num, Height, Width, Channel].</li> <li>See Parameter Restrictions below for     information on the expected shape of the input tensor.</li> <li> <p>Must follow general tensor requirements</p> </li> <li> <p><code>padding_type</code></p> </li> <li> <p>The type of padding to use for the pooling operations.</p> </li> <li>Valid values: are <code>SAME_PADDING</code> or <code>VALID_PADDING</code>.</li> <li>See Parameter Restrictions below for     information on the expected value of padding_type.</li> <li> <p>For information on \"same\" vs \"valid\" padding see:     https://www.pico.net/kb/what-is-the-difference-between-same-and-valid-padding-in-tf-nn-max-pool-of-tensorflow.</p> </li> <li> <p><code>kernel_height</code></p> </li> <li> <p>Size of the kernel window that passes over the input's height dimension.</p> </li> <li> <p>See Parameter Restrictions below for     information on the expected value of kerneL_height.</p> </li> <li> <p><code>kernel_width</code></p> </li> <li> <p>Size of the kernel window that passes over the input's width dimension.</p> </li> <li> <p>See Parameter Restrictions below for     information on the expected value of kerneL_width.</p> </li> <li> <p><code>stride_height</code></p> </li> <li> <p>Number of positions the kernel moves over input's height dimension at each     step.</p> </li> <li>If <code>stride_height</code> is 0 then <code>stride_width</code> must also be 0.</li> <li> <p>If strides are greater than 0 then <code>stride_height</code> must be less than or     equal to 30.</p> </li> <li> <p><code>stride_width</code></p> </li> <li> <p>Number of positions the kernel moves over the input's width dimension at     each step.</p> </li> <li>If <code>stride_height</code> is 0 then <code>stride_width</code> must also be 0.</li> <li> <p>If strides are greater than 0 then <code>stride_width</code> must be less than or equal     to 30.</p> </li> <li> <p><code>zdnn_ztensor *output</code></p> </li> <li>The result tensor which will hold the result of the pooling operation its     buffer.</li> <li>Must be a ZDNN_NHWC tensor with pre_transformed shape     [batch_Num, Height, Width, Channel].</li> <li>See Parameter Restrictions below for     information on the expected shape of the output tensor.</li> <li>Must follow general tensor requirements</li> </ul>"},{"location":"zDNN/#maxpool2d-parameter-restrictions","title":"MaxPool2D Parameter Restrictions","text":"<p>Parameter restrictions may vary based on provided strides and padding_type.</p> <ul> <li> <p>Input tensor batch_Num and Channel dimensions must always match the output   tensor's respective dimensions.</p> </li> <li> <p>If strides are 0:</p> </li> <li>Both input tensor's Height dimension and the kernel_height must match and be     less than or equal to 1024.</li> <li>Both input tensor's Width dimension and the kernel_width must match and be     less than or equal to 1024.</li> <li>Output tensor's height and width dimensions must be 1.</li> <li>padding_type must be <code>VALID_PADDING</code>.</li> <li>If strides are greater than zero:</li> <li>kernel_width and kernel_height must be less than or equal to 64.</li> <li>input tensor's height or weight dimension must not be greater than 1024.</li> <li>If padding_type is <code>SAME_PADDING</code>:<ul> <li>Output tensor's height dimension must equal   <code>ceil((float)input's height / stride_height)</code>.</li> <li>Output tensor's width dimension must equal   <code>ceil((float)input's width / stride_width)</code>.</li> </ul> </li> <li>If padding_type is <code>VALID_PADDING</code>:<ul> <li>Output tensor's height dimension must equal   <code>ceil((float)(input's height - kernel_height + 1) / stride_height)</code>.</li> <li>Output tensor's width dimension must equal   <code>ceil((float)(input's width - kernel_width + 1) / stride_width)</code>.</li> </ul> </li> </ul>"},{"location":"zDNN/#programming-notes_10","title":"Programming Notes","text":"<ul> <li>If the magnitude of difference between elements of <code>input</code> is large (greater   than 10), accuracy may be reduced.</li> </ul>"},{"location":"zDNN/#returns-see-zdnn-statuses-for-descriptions_18","title":"Returns (see zDNN Statuses for descriptions)","text":"<ul> <li><code>ZDNN_OK</code></li> <li><code>ZDNN_INVALID_SHAPE</code></li> <li>Shape of input or output tensor is invalid based on given kernel and stride     parameters</li> <li>Other general shape violations (exceeds MDIS, etc.)</li> <li><code>ZDNN_INVALID_TYPE</code></li> <li><code>ZDNN_INVALID_FORMAT</code></li> <li><code>ZDNN_INVALID_STRIDE_PADDING</code></li> <li><code>ZDNN_INVALID_STRIDES</code> - One stride was non-zero, but not the other.</li> <li>hardware statuses</li> <li><code>ZDNN_EXCEEDS_MDIS</code> will also occur if any of the following conditions     occur:<ul> <li>stride_height is larger than <code>zdnn_get_nnpa_max_dim_idx_size</code>.</li> <li>stride_width is larger than <code>zdnn_get_nnpa_max_dim_idx_size</code>.</li> <li>kernel_height is 0 or is larger than <code>zdnn_get_nnpa_max_dim_idx_size</code>.</li> <li>kernel_width is 0 or is larger than <code>zdnn_get_nnpa_max_dim_idx_size</code>.</li> </ul> </li> <li><code>ZDNN_FUNC_RC_F000</code> - Invalid <code>padding_type</code></li> <li><code>ZDNN_FUNC_RC_F001</code> - <code>stride_height</code> = 0 and <code>stride_width</code> = 0, but a     kernel parameter is greater than allowed (see <code>kernel_height</code> or     <code>kernel_width</code> above)</li> <li><code>ZDNN_FUNC_RC_F002</code> - <code>stride_height</code> &gt; 0 and <code>stride_width</code> &gt; 0, but a     kernel parameter is greater than allowed (see <code>kernel_height</code> or     <code>kernel_width</code> above)</li> <li><code>ZDNN_FUNC_RC_F003</code> - <code>stride_height</code> &gt; 0 and <code>stride_width</code> &gt; 0, but a     stride parameter is greater than allowed (see <code>stride_height</code> or     <code>stride_width</code> above)</li> <li><code>ZDNN_FUNC_RC_F004</code> - <code>stride_height</code> &gt; 0 and <code>stride_width</code> &gt; 0, but either     input tensor's height or weight dimension is greater than 1024.</li> </ul>"},{"location":"zDNN/#framework-examples_19","title":"Framework Examples","text":"<p>TensorFlow MaxPool</p> <p>https://www.tensorflow.org/api_docs/cc/class/tensorflow/ops/max-pool</p> <p>ONNX MaxPool</p> <p>https://github.com/onnx/onnx/blob/master/docs/Operators.md#MaxPool</p>"},{"location":"zDNN/#zdnn_conv2d","title":"zdnn_conv2d","text":"<p>Back to Table of Contents</p>"},{"location":"zDNN/#description_47","title":"Description","text":"<p>Perform 2D convolution over an input tensor in zDNN transformed format.</p> <p>First the <code>input</code> tensor is convolved with the <code>kernel</code> tensor. Then the <code>bias</code> tensor is added to the results. Then if <code>act_func</code> is not <code>CONV2D_ACT_NONE</code>, the activation function is applied to the results. Then if <code>act_func</code> is set to <code>CONV2D_ACT_RELU</code>, and clipping_value is not <code>NULL</code> or <code>0</code>, clipping is performed against the intermediate result where z = min(intermediate_result, clipping_value). Finally the results are stored into the provided output zDNN tensor.</p>"},{"location":"zDNN/#format_47","title":"Format","text":"<pre><code>zdnn_status zdnn_conv2d(const zdnn_ztensor *input,\n                        const zdnn_ztensor *kernel,\n                        const zdnn_ztensor *bias,\n                        zdnn_pool_padding padding_type,\n                        uint32_t stride_height, uint32_t stride_width,\n                        zdnn_conv2d_act act_func,\n                        const void *clipping_value, zdnn_ztensor *output);\n</code></pre>"},{"location":"zDNN/#parameters_45","title":"Parameters","text":"<ul> <li> <p><code>zdnn_ztensor *input</code></p> </li> <li> <p>Tensor with original values to be downsampled in the output tensor.</p> </li> <li>Must be a ZDNN_NHWC tensor with pre_transformed shape     [num_batches, height_in, width_in, channels_in].</li> <li>See Convolution 2D Requirements for     requirements.</li> <li> <p>Must follow general tensor requirements</p> </li> <li> <p><code>zdnn_ztensor *kernel</code></p> </li> <li> <p>The kernel tensor to convolute with the input tensor.</p> </li> <li>Must be a ZDNN_HWCK tensor with pre_transformed shape     [kernel_height, kernel_width, channels_in, channels_out].</li> <li>See Convolution 2D Requirements for     requirements.</li> <li> <p>Must follow general tensor requirements</p> </li> <li> <p><code>zdnn_ztensor *bias</code></p> </li> <li> <p>The bias tensor to add to the convoluted results.</p> </li> <li>Must be a ZDNN_1D tensor with pre_transformed shape     [channels_out].</li> <li>See Convolution 2D Requirements for     requirements.</li> <li> <p>Must follow general tensor requirements</p> </li> <li> <p><code>zdnn_pool_padding padding_type</code></p> </li> <li> <p>The type of padding to use for the pooling operations.</p> </li> <li>Valid values: are <code>SAME_PADDING</code> or <code>VALID_PADDING</code>.</li> <li> <p>For information on \"same\" vs \"valid\" padding see:     https://www.pico.net/kb/what-is-the-difference-between-same-and-valid-padding-in-tf-nn-max-pool-of-tensorflow.</p> </li> <li> <p><code>uint32_t stride_height</code></p> </li> <li> <p>Number of positions the kernel moves over the input's <code>dim3</code> dimension at     each step.</p> </li> <li> <p>See Convolution 2D Requirements for     requirements.</p> </li> <li> <p><code>uint32_t stride_width</code></p> </li> <li> <p>Number of positions the kernel moves over the input's <code>dim2</code> dimension at     each step.</p> </li> <li> <p>See Convolution 2D Requirements for     requirements.</p> </li> <li> <p><code>zdnn_conv2d_act act_func</code></p> </li> <li> <p>Activation function to apply to the results.</p> </li> <li> <p><code>CONV2D_ACT_NONE</code> or <code>CONV2D_ACT_RELU</code></p> </li> <li> <p><code>void *clipping_value</code></p> </li> <li> <p>A pointer to an FP32 value, used to clip input tensor's elements.</p> </li> <li>If set to NULL or 0, no clipping will occur.</li> <li>Must not be a negative value.</li> <li> <p>Value is ignored if <code>act_func</code> is not set to <code>CONV2D_ACT_RELU</code>.</p> </li> <li> <p><code>zdnn_ztensor *output</code></p> </li> <li> <p>The result tensor which will hold the results.</p> </li> <li>Must be a ZDNN_NHWC tensor with pre_transformed shape     [num_batches, height_out, width_out, channels_out].</li> <li>See Convolution 2D Requirements for     requirements.</li> <li>Must follow general tensor requirements</li> </ul>"},{"location":"zDNN/#convolution-2d-requirements","title":"Convolution 2D Requirements","text":"strides and padding input (num_batches, height_in, width_in, channels_in) kernel (kernel_height, kernel_width, channels_in, channels_out) bias (channels_out) output (num_batches, height_out, width_out, channels_out) both strides &gt; 0 and =&lt; 13, SAME padding both kernel_height and kernel_width must be =&lt; 64 height_out = ceil(kernel_height/stride_height)width_out = ceil(kernel_width/stride_width) both strides &gt; 0 and =&lt; 13, VALID padding height_in must be &gt; kernel_heightwidth_in must be &gt; kernel_width both kernel_height and kernel_width must be =&lt; 64 height_out = ceil((height_in - kernel_height + 1)/stride_height)width_out = ceil((width_in - kernel_width + 1)/stride_width) both strides = 0, VALID padding height_in must be = kernel_heightwidth_in must be = kernel_width both kernel_height and kernel_width must be =&lt; 448 both height_out and width_out must be 1"},{"location":"zDNN/#returns-see-zdnn-statuses-for-descriptions_19","title":"Returns (see zDNN Statuses for descriptions)","text":"<ul> <li><code>ZDNN_OK</code></li> <li>warning statuses</li> <li><code>ZDNN_INVALID_SHAPE</code></li> <li>Shape of input or output tensor is invalid based on given kernel and stride     parameters</li> <li>Other general shape violations (exceeds MDIS, etc.)</li> <li><code>ZDNN_INVALID_TYPE</code></li> <li><code>ZDNN_INVALID_FORMAT</code></li> <li><code>ZDNN_INVALID_STRIDE_PADDING</code></li> <li><code>ZDNN_INVALID_STRIDES</code></li> <li><code>ZDNN_INVALID_CLIPPING_VALUE</code></li> <li>hardware statuses</li> <li><code>ZDNN_FUNC_RC_F000</code> - Invalid <code>padding_type</code></li> <li><code>ZDNN_FUNC_RC_F001</code> - Invalid <code>act_func</code></li> <li><code>ZDNN_FUNC_RC_F002</code> - <code>stride_height</code> = 0 and <code>stride_width</code> = 0, but either     <code>kernel_height</code> or <code>kernel_width</code> &gt; 448</li> <li><code>ZDNN_FUNC_RC_F003</code> - <code>stride_height</code> &gt; 0 and <code>stride_width</code> &gt; 0, but either     <code>kernel_height</code> or <code>kernel_width</code> &gt; 64</li> <li><code>ZDNN_FUNC_RC_F004</code> - Either <code>stride_height</code> or <code>stride_width</code> &gt; 13</li> </ul>"},{"location":"zDNN/#framework-examples_20","title":"Framework Examples","text":"<p>TensorFlow Conv2D</p> <p>https://www.tensorflow.org/api_docs/python/tf/keras/layers/Conv2D</p> <p>ONNX Conv2D</p>"},{"location":"zDNN/#convenience-functions","title":"Convenience Functions","text":"<p>Back to Table of Contents</p> <ul> <li>None</li> </ul>"},{"location":"zDNN/#usage-examples","title":"Usage Examples","text":""},{"location":"zDNN/#example-flow-of-an-application-calling-the-zdnn-apis","title":"Example flow of an application calling the zDNN APIs","text":"<p>Back to Table of Contents</p> <pre><code>#include &lt;assert.h&gt;\n#include &lt;stdint.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n\n#include \"zdnn.h\"\n\n// ***************************************************************************\n// Sample:\n//\n// Create 2 zTensors a and b, and add them together via zdnn_add()\n// ***************************************************************************\nint main(int argc, char *argv[]) {\n  zdnn_tensor_desc pre_tfrmd_desc, tfrmd_desc;\n  zdnn_ztensor ztensor_a;\n  zdnn_ztensor ztensor_b;\n  zdnn_ztensor ztensor_out;\n  zdnn_status status;\n\n  uint32_t dim_n = 1, dim_h = 32, dim_w = 32, dim_c = 3;\n  zdnn_data_types type = FP32;\n  short element_size = 4; // size of each element in bytes\n  uint64_t num_elements = dim_n * dim_h * dim_w * dim_c;\n\n  // allocate tensor data storage\n  void *data1 = malloc(num_elements * element_size);\n  void *data2 = malloc(num_elements * element_size);\n  void *data_out = malloc(num_elements * element_size);\n\n  // read input_data\n\n  // check status for AIU availability, supported ops, etc. here\n  // status = zdnn_query(\u2026);\n\n  // set input tensor data to 0 to 127 sequentially and repeat\n  for (uint64_t i = 0; i &lt; num_elements; i++) {\n    ((float *)data1)[i] = (float)(i &amp; 0x7f);\n    ((float *)data2)[i] = (float)(i &amp; 0x7f);\n  }\n\n  zdnn_init_pre_transformed_desc(ZDNN_NHWC, type, &amp;pre_tfrmd_desc, dim_n, dim_h,\n                                 dim_w, dim_c);\n  // generate transformed shape information\n  status = zdnn_generate_transformed_desc(&amp;pre_tfrmd_desc, &amp;tfrmd_desc);\n  assert(status == ZDNN_OK);\n\n  // initialize zTensors and allocate 4k-aligned storage via helper function\n  status =\n      zdnn_init_ztensor_with_malloc(&amp;pre_tfrmd_desc, &amp;tfrmd_desc, &amp;ztensor_a);\n  assert(status == ZDNN_OK);\n  status =\n      zdnn_init_ztensor_with_malloc(&amp;pre_tfrmd_desc, &amp;tfrmd_desc, &amp;ztensor_b);\n  assert(status == ZDNN_OK);\n  status =\n      zdnn_init_ztensor_with_malloc(&amp;pre_tfrmd_desc, &amp;tfrmd_desc, &amp;ztensor_out);\n  assert(status == ZDNN_OK);\n\n  // transform the feature tensor\n  status = zdnn_transform_ztensor(&amp;ztensor_a, data1);\n  assert(status == ZDNN_OK);\n  status = zdnn_transform_ztensor(&amp;ztensor_b, data2);\n  assert(status == ZDNN_OK);\n\n  // perform element-wise add between the two input tensors\n  status = zdnn_add(&amp;ztensor_a, &amp;ztensor_b, &amp;ztensor_out);\n  assert(status == ZDNN_OK);\n\n  // transform resultant zTensor back to original data format\n  status = zdnn_transform_origtensor(&amp;ztensor_out, data_out);\n  assert(status == ZDNN_OK);\n\n  for (uint64_t i = 0; i &lt; num_elements; i++) {\n    printf(\"out element %\" PRIu64 \" %f\\n\", i, ((float *)data_out)[i]);\n  }\n\n  free(data1);\n  free(data2);\n  free(data_out);\n}\n</code></pre>"},{"location":"zDNN/#example-of-an-application-calling-the-zdnn_lstm-api-forward","title":"Example of an application calling the zdnn_lstm API (forward)","text":"<p>Back to Table of Contents</p> <pre><code>// SPDX-License-Identifier: Apache-2.0\n/*\n\u00a0* Copyright IBM Corp. 2021\n\u00a0*\u00a0\n\u00a0* Licensed under the Apache License, Version 2.0 (the \"License\");\n\u00a0* you may not use this file except in compliance with the License.\n\u00a0* You may obtain a copy of the License at\n\u00a0*\u00a0\n\u00a0*\u00a0\u00a0\u00a0\u00a0 http://www.apache.org/licenses/LICENSE-2.0\n\u00a0*\u00a0\n\u00a0* Unless required by applicable law or agreed to in writing, software\n\u00a0* distributed under the License is distributed on an \"AS IS\" BASIS,\n\u00a0* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\u00a0* See the License for the specific language governing permissions and\n\u00a0* limitations under the License.\n\u00a0*/\n\n#include &lt;assert.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n\n#include \"zdnn.h\"\n\n// Sample: LSTM\nint main(int argc, char *argv[]) {\n  zdnn_status status;\n\n#ifdef STATIC_LIB\n  zdnn_init();\n#endif\n\n  /***********************************************************************\n   *\n   * LSTM (FWD/BWD):\n   *\n   * INPUTS --------------------------------------------------------------\n   * input           |  ZDNN_3DS  | (num_timesteps, num_batches, num_features)\n   * h0              |  ZDNN_3DS  | (1, num_batches, num_hidden)\n   * c0              |  ZDNN_3DS  | (1, num_batches, num_hidden)\n   * weights         |  ZDNN_3DS  | (1, num_features, num_hidden)\n   * biases          |  ZDNN_2DS  | (1, num_hidden)\n   * hidden_weights  |  ZDNN_3DS  | (1, num_hidden, num_hidden)\n   * hidden_biases   |  ZDNN_2DS  | (1, num_hidden)\n   *\n   * OUTPUTS -------------------------------------------------------------\n   * hn_output       |  ZDNN_4DS  | (num_timesteps, 1, num_batches, num_hidden)\n   *                 |            | or (1, 1, num_batches, num_hidden)\n   * cf_output       |  ZDNN_4DS  | (1, 1, num_batches, num_hidden)\n   ***********************************************************************/\n\n  /***********************************************************************\n   * Create input zTensor\n   ***********************************************************************/\n\n  zdnn_tensor_desc input_pre_tfrmd_desc, input_tfrmd_desc;\n  zdnn_ztensor input;\n\n  uint32_t num_timesteps = 5;\n  uint32_t num_batches = 3;\n  uint32_t num_features = 32;\n  uint32_t num_hidden = 5;\n\n  zdnn_data_types type = FP32;\n  short element_size = 4; // size of each element in bytes\n\n  lstm_gru_direction dir = FWD;\n  uint8_t num_dirs = 1;\n\n  zdnn_init_pre_transformed_desc(ZDNN_3DS, type, &amp;input_pre_tfrmd_desc,\n                                 num_timesteps, num_batches, num_features);\n  status =\n      zdnn_generate_transformed_desc(&amp;input_pre_tfrmd_desc, &amp;input_tfrmd_desc);\n  assert(status == ZDNN_OK);\n  status = zdnn_init_ztensor_with_malloc(&amp;input_pre_tfrmd_desc,\n                                         &amp;input_tfrmd_desc, &amp;input);\n  assert(status == ZDNN_OK);\n\n  uint64_t input_data_size =\n      num_timesteps * num_batches * num_features * element_size;\n  void *input_data = malloc(input_data_size);\n\n  status = zdnn_transform_ztensor(&amp;input, input_data);\n  assert(status == ZDNN_OK);\n\n  /***********************************************************************\n   * Create initial hidden and cell state zTensors\n   ***********************************************************************/\n\n  zdnn_tensor_desc h0c0_pre_tfrmd_desc, h0c0_tfrmd_desc;\n  zdnn_ztensor h0, c0;\n\n  zdnn_init_pre_transformed_desc(ZDNN_3DS, type, &amp;h0c0_pre_tfrmd_desc, num_dirs,\n                                 num_batches, num_hidden);\n  status =\n      zdnn_generate_transformed_desc(&amp;h0c0_pre_tfrmd_desc, &amp;h0c0_tfrmd_desc);\n  assert(status == ZDNN_OK);\n\n  status = zdnn_init_ztensor_with_malloc(&amp;h0c0_pre_tfrmd_desc, &amp;h0c0_tfrmd_desc,\n                                         &amp;h0);\n  assert(status == ZDNN_OK);\n  status = zdnn_init_ztensor_with_malloc(&amp;h0c0_pre_tfrmd_desc, &amp;h0c0_tfrmd_desc,\n                                         &amp;c0);\n  assert(status == ZDNN_OK);\n\n  uint64_t h0c0_data_size = num_batches * num_hidden * element_size;\n  void *hidden_state_data = malloc(h0c0_data_size);\n  void *cell_state_data = malloc(h0c0_data_size);\n\n  status = zdnn_transform_ztensor(&amp;h0, hidden_state_data);\n  assert(status == ZDNN_OK);\n  status = zdnn_transform_ztensor(&amp;c0, cell_state_data);\n  assert(status == ZDNN_OK);\n\n  /***********************************************************************\n   * Create input weights zTensor\n   * Resultant zTensor is concatenated\n   ***********************************************************************/\n\n  zdnn_tensor_desc weights_pre_tfrmd_desc, weights_tfrmd_desc;\n  zdnn_ztensor weights;\n\n  zdnn_init_pre_transformed_desc(ZDNN_3DS, type, &amp;weights_pre_tfrmd_desc,\n                                 num_dirs, num_features, num_hidden);\n  status = zdnn_generate_transformed_desc_concatenated(\n      &amp;weights_pre_tfrmd_desc, RNN_TYPE_LSTM | USAGE_WEIGHTS | PREV_LAYER_NONE,\n      &amp;weights_tfrmd_desc);\n  assert(status == ZDNN_OK);\n\n  status = zdnn_init_ztensor_with_malloc(&amp;weights_pre_tfrmd_desc,\n                                         &amp;weights_tfrmd_desc, &amp;weights);\n  assert(status == ZDNN_OK);\n\n  uint64_t weights_data_size = num_features * num_hidden * element_size;\n  void *weights_data_f = malloc(weights_data_size);\n  void *weights_data_i = malloc(weights_data_size);\n  void *weights_data_c = malloc(weights_data_size);\n  void *weights_data_o = malloc(weights_data_size);\n\n  status = zdnn_transform_ztensor(&amp;weights, weights_data_f, weights_data_i,\n                                  weights_data_c, weights_data_o);\n  assert(status == ZDNN_OK);\n\n  /***********************************************************************\n   * Create biases zTensors\n   * Resultant zTensors are concatenated\n   ***********************************************************************/\n\n  zdnn_tensor_desc biases_pre_tfrmd_desc, biases_tfrmd_desc;\n  zdnn_ztensor biases;\n\n  zdnn_init_pre_transformed_desc(ZDNN_2DS, type, &amp;biases_pre_tfrmd_desc,\n                                 num_dirs, num_hidden);\n  status = zdnn_generate_transformed_desc_concatenated(\n      &amp;biases_pre_tfrmd_desc, RNN_TYPE_LSTM | USAGE_BIASES | PREV_LAYER_NONE,\n      &amp;biases_tfrmd_desc);\n  assert(status == ZDNN_OK);\n\n  status = zdnn_init_ztensor_with_malloc(&amp;biases_pre_tfrmd_desc,\n                                         &amp;biases_tfrmd_desc, &amp;biases);\n  assert(status == ZDNN_OK);\n\n  uint64_t biases_data_size = num_hidden * element_size;\n  void *biases_data_f = malloc(biases_data_size);\n  void *biases_data_i = malloc(biases_data_size);\n  void *biases_data_c = malloc(biases_data_size);\n  void *biases_data_o = malloc(biases_data_size);\n\n  status = zdnn_transform_ztensor(&amp;biases, biases_data_f, biases_data_i,\n                                  biases_data_c, biases_data_o);\n  assert(status == ZDNN_OK);\n\n  /***********************************************************************\n   * Create hidden weights zTensor\n   * Resultant zTensor is concatenated\n   ***********************************************************************/\n\n  zdnn_tensor_desc hidden_weights_pre_tfrmd_desc, hidden_weights_tfrmd_desc;\n  zdnn_ztensor hidden_weights;\n\n  zdnn_init_pre_transformed_desc(ZDNN_3DS, type, &amp;hidden_weights_pre_tfrmd_desc,\n                                 num_dirs, num_hidden, num_hidden);\n  status = zdnn_generate_transformed_desc_concatenated(\n      &amp;hidden_weights_pre_tfrmd_desc,\n      RNN_TYPE_LSTM | USAGE_HIDDEN_WEIGHTS | PREV_LAYER_NONE,\n      &amp;hidden_weights_tfrmd_desc);\n  assert(status == ZDNN_OK);\n  status = zdnn_init_ztensor_with_malloc(&amp;hidden_weights_pre_tfrmd_desc,\n                                         &amp;hidden_weights_tfrmd_desc,\n                                         &amp;hidden_weights);\n  assert(status == ZDNN_OK);\n\n  uint64_t hidden_weights_data_size = num_hidden * num_hidden * element_size;\n  void *hidden_weights_data_f = malloc(hidden_weights_data_size);\n  void *hidden_weights_data_i = malloc(hidden_weights_data_size);\n  void *hidden_weights_data_c = malloc(hidden_weights_data_size);\n  void *hidden_weights_data_o = malloc(hidden_weights_data_size);\n\n  status = zdnn_transform_ztensor(&amp;hidden_weights, hidden_weights_data_f,\n                                  hidden_weights_data_i, hidden_weights_data_c,\n                                  hidden_weights_data_o);\n  assert(status == ZDNN_OK);\n\n  /***********************************************************************\n   * Create hidden biases zTensors\n   * Resultant zTensors are concatenated\n   ***********************************************************************/\n\n  zdnn_tensor_desc hidden_biases_pre_tfrmd_desc, hidden_biases_tfrmd_desc;\n  zdnn_ztensor hidden_biases;\n\n  zdnn_init_pre_transformed_desc(ZDNN_2DS, type, &amp;hidden_biases_pre_tfrmd_desc,\n                                 num_dirs, num_hidden);\n  status = zdnn_generate_transformed_desc_concatenated(\n      &amp;hidden_biases_pre_tfrmd_desc,\n      RNN_TYPE_LSTM | USAGE_HIDDEN_BIASES | PREV_LAYER_NONE,\n      &amp;hidden_biases_tfrmd_desc);\n  assert(status == ZDNN_OK);\n\n  status = zdnn_init_ztensor_with_malloc(\n      &amp;hidden_biases_pre_tfrmd_desc, &amp;hidden_biases_tfrmd_desc, &amp;hidden_biases);\n  assert(status == ZDNN_OK);\n\n  uint64_t hidden_biases_data_size = num_hidden * element_size;\n\n  void *hidden_biases_data_f = malloc(hidden_biases_data_size);\n  void *hidden_biases_data_i = malloc(hidden_biases_data_size);\n  void *hidden_biases_data_c = malloc(hidden_biases_data_size);\n  void *hidden_biases_data_o = malloc(hidden_biases_data_size);\n\n  status = zdnn_transform_ztensor(&amp;hidden_biases, hidden_biases_data_f,\n                                  hidden_biases_data_i, hidden_biases_data_c,\n                                  hidden_biases_data_o);\n  assert(status == ZDNN_OK);\n\n  /***********************************************************************\n   * Create output zTensor\n   ***********************************************************************/\n\n  // get only the last timestep, thus hn and cf can share descriptor\n  zdnn_tensor_desc hncf_pre_tfrmd_desc, hncf_tfrmd_desc;\n\n  zdnn_ztensor hn_output_ztensor, cf_output_ztensor;\n\n  zdnn_init_pre_transformed_desc(ZDNN_4DS, type, &amp;hncf_pre_tfrmd_desc, 1, 1,\n                                 num_batches, num_hidden);\n  status =\n      zdnn_generate_transformed_desc(&amp;hncf_pre_tfrmd_desc, &amp;hncf_tfrmd_desc);\n  assert(status == ZDNN_OK);\n\n  status = zdnn_init_ztensor_with_malloc(&amp;hncf_pre_tfrmd_desc, &amp;hncf_tfrmd_desc,\n                                         &amp;hn_output_ztensor);\n  assert(status == ZDNN_OK);\n  status = zdnn_init_ztensor_with_malloc(&amp;hncf_pre_tfrmd_desc, &amp;hncf_tfrmd_desc,\n                                         &amp;cf_output_ztensor);\n  assert(status == ZDNN_OK);\n\n  /***********************************************************************\n   * Call the AIU\n   ***********************************************************************/\n\n  void *work_area = NULL;\n\n  status = zdnn_lstm(&amp;input, &amp;h0, &amp;c0, &amp;weights, &amp;biases, &amp;hidden_weights,\n                     &amp;hidden_biases, dir, work_area, &amp;hn_output_ztensor,\n                     &amp;cf_output_ztensor);\n  assert(status == ZDNN_OK);\n\n  /***********************************************************************\n   * Output and Cleanup\n   ***********************************************************************/\n\n  uint64_t hncf_data_size = num_batches * num_hidden * element_size;\n  void *hn_output_data = malloc(hncf_data_size);\n  void *cf_output_data = malloc(hncf_data_size);\n\n  status = zdnn_transform_origtensor(&amp;hn_output_ztensor, hn_output_data);\n  assert(status == ZDNN_OK);\n  status = zdnn_transform_origtensor(&amp;cf_output_ztensor, cf_output_data);\n  assert(status == ZDNN_OK);\n\n  status = zdnn_free_ztensor_buffer(&amp;input);\n  assert(status == ZDNN_OK);\n  status = zdnn_free_ztensor_buffer(&amp;h0);\n  assert(status == ZDNN_OK);\n  status = zdnn_free_ztensor_buffer(&amp;c0);\n  assert(status == ZDNN_OK);\n  status = zdnn_free_ztensor_buffer(&amp;weights);\n  assert(status == ZDNN_OK);\n  status = zdnn_free_ztensor_buffer(&amp;biases);\n  assert(status == ZDNN_OK);\n  status = zdnn_free_ztensor_buffer(&amp;hidden_weights);\n  assert(status == ZDNN_OK);\n  status = zdnn_free_ztensor_buffer(&amp;hidden_biases);\n  assert(status == ZDNN_OK);\n  status = zdnn_free_ztensor_buffer(&amp;hn_output_ztensor);\n  assert(status == ZDNN_OK);\n  status = zdnn_free_ztensor_buffer(&amp;cf_output_ztensor);\n  assert(status == ZDNN_OK);\n\n  free(input_data);\n  free(hidden_state_data);\n  free(cell_state_data);\n  free(weights_data_f);\n  free(weights_data_i);\n  free(weights_data_c);\n  free(weights_data_o);\n  free(hidden_weights_data_f);\n  free(hidden_weights_data_i);\n  free(hidden_weights_data_c);\n  free(hidden_weights_data_o);\n  free(biases_data_f);\n  free(biases_data_i);\n  free(biases_data_c);\n  free(biases_data_o);\n  free(hidden_biases_data_f);\n  free(hidden_biases_data_i);\n  free(hidden_biases_data_c);\n  free(hidden_biases_data_o);\n  free(hn_output_data);\n  free(cf_output_data);\n}\n</code></pre>"},{"location":"zDNN/#example-of-an-application-calling-the-zdnn_lstm-api-bi-directional","title":"Example of an application calling the zdnn_lstm API (bi-directional)","text":"<p>Back to Table of Contents</p> <pre><code>// SPDX-License-Identifier: Apache-2.0\n/*\n\u00a0* Copyright IBM Corp. 2021\n\u00a0*\u00a0\n\u00a0* Licensed under the Apache License, Version 2.0 (the \"License\");\n\u00a0* you may not use this file except in compliance with the License.\n\u00a0* You may obtain a copy of the License at\n\u00a0*\u00a0\n\u00a0*\u00a0\u00a0\u00a0\u00a0 http://www.apache.org/licenses/LICENSE-2.0\n\u00a0*\u00a0\n\u00a0* Unless required by applicable law or agreed to in writing, software\n\u00a0* distributed under the License is distributed on an \"AS IS\" BASIS,\n\u00a0* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\u00a0* See the License for the specific language governing permissions and\n\u00a0* limitations under the License.\n\u00a0*/\n\n#include &lt;assert.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n\n#include \"zdnn.h\"\n\n// Sample: LSTM BI-DIR\nint main(int argc, char *argv[]) {\n  zdnn_status status;\n\n#ifdef STATIC_LIB\n  zdnn_init();\n#endif\n\n  /***********************************************************************\n   *\n   * LSTM (BI-DIR):\n   *\n   * INPUTS --------------------------------------------------------------\n   * input           |  ZDNN_3DS  | (num_timesteps, num_batches, num_features)\n   * h0              |  ZDNN_3DS  | (2, num_batches, num_hidden)\n   * c0              |  ZDNN_3DS  | (2, num_batches, num_hidden)\n   * weights         |  ZDNN_3DS  | (2, num_features, num_hidden)\n   * biases          |  ZDNN_2DS  | (2, num_hidden)\n   * hidden_weights  |  ZDNN_3DS  | (2, num_hidden, num_hidden)\n   * hidden_biases   |  ZDNN_2DS  | (2, num_hidden)\n   *\n   * OUTPUTS -------------------------------------------------------------\n   * hn_output       |  ZDNN_4DS  | (num_timesteps, 2, num_batches, num_hidden)\n   *                 |            | or (1, 2, num_batches, num_hidden)\n   * cf_output       |  ZDNN_4DS  | (1, 2, num_batches, num_hidden)\n   ***********************************************************************/\n\n  /***********************************************************************\n   * Create input zTensor\n   ***********************************************************************/\n\n  zdnn_tensor_desc input_pre_tfrmd_desc, input_tfrmd_desc;\n  zdnn_ztensor input;\n\n  uint32_t num_timesteps = 5;\n  uint32_t num_batches = 3;\n  uint32_t num_features = 32;\n  uint32_t num_hidden = 5;\n\n  zdnn_data_types type = FP32;\n  short element_size = 4; // size of each element in bytes\n\n  lstm_gru_direction dir = BIDIR;\n  uint8_t num_dirs = 2;\n\n  zdnn_init_pre_transformed_desc(ZDNN_3DS, type, &amp;input_pre_tfrmd_desc,\n                                 num_timesteps, num_batches, num_features);\n  status =\n      zdnn_generate_transformed_desc(&amp;input_pre_tfrmd_desc, &amp;input_tfrmd_desc);\n  assert(status == ZDNN_OK);\n  status = zdnn_init_ztensor_with_malloc(&amp;input_pre_tfrmd_desc,\n                                         &amp;input_tfrmd_desc, &amp;input);\n  assert(status == ZDNN_OK);\n\n  uint64_t input_data_size =\n      num_timesteps * num_batches * num_features * element_size;\n  void *input_data = malloc(input_data_size);\n\n  status = zdnn_transform_ztensor(&amp;input, input_data);\n  assert(status == ZDNN_OK);\n\n  /***********************************************************************\n   * Create initial hidden and cell state zTensors\n   ***********************************************************************/\n\n  zdnn_tensor_desc h0c0_pre_tfrmd_desc, h0c0_tfrmd_desc;\n  zdnn_ztensor h0, c0;\n\n  zdnn_init_pre_transformed_desc(ZDNN_3DS, type, &amp;h0c0_pre_tfrmd_desc, num_dirs,\n                                 num_batches, num_hidden);\n  status =\n      zdnn_generate_transformed_desc(&amp;h0c0_pre_tfrmd_desc, &amp;h0c0_tfrmd_desc);\n  assert(status == ZDNN_OK);\n\n  status = zdnn_init_ztensor_with_malloc(&amp;h0c0_pre_tfrmd_desc, &amp;h0c0_tfrmd_desc,\n                                         &amp;h0);\n  assert(status == ZDNN_OK);\n  status = zdnn_init_ztensor_with_malloc(&amp;h0c0_pre_tfrmd_desc, &amp;h0c0_tfrmd_desc,\n                                         &amp;c0);\n  assert(status == ZDNN_OK);\n\n  uint64_t h0c0_data_size = num_batches * num_hidden * element_size;\n  void *hidden_state_data = malloc(h0c0_data_size);\n  void *cell_state_data = malloc(h0c0_data_size);\n\n  status = zdnn_transform_ztensor(&amp;h0, hidden_state_data);\n  assert(status == ZDNN_OK);\n  status = zdnn_transform_ztensor(&amp;c0, cell_state_data);\n  assert(status == ZDNN_OK);\n\n  /***********************************************************************\n   * Create input weights zTensor\n   * Resultant zTensor is concatenated\n   ***********************************************************************/\n\n  zdnn_tensor_desc weights_pre_tfrmd_desc, weights_tfrmd_desc;\n  zdnn_ztensor weights;\n\n  zdnn_init_pre_transformed_desc(ZDNN_3DS, type, &amp;weights_pre_tfrmd_desc,\n                                 num_dirs, num_features, num_hidden);\n  status = zdnn_generate_transformed_desc_concatenated(\n      &amp;weights_pre_tfrmd_desc, RNN_TYPE_LSTM | USAGE_WEIGHTS | PREV_LAYER_NONE,\n      &amp;weights_tfrmd_desc);\n  assert(status == ZDNN_OK);\n\n  status = zdnn_init_ztensor_with_malloc(&amp;weights_pre_tfrmd_desc,\n                                         &amp;weights_tfrmd_desc, &amp;weights);\n  assert(status == ZDNN_OK);\n\n  uint64_t weights_data_size = num_features * num_hidden * element_size;\n  void *weights_data_f = malloc(weights_data_size);\n  void *weights_data_i = malloc(weights_data_size);\n  void *weights_data_c = malloc(weights_data_size);\n  void *weights_data_o = malloc(weights_data_size);\n\n  status = zdnn_transform_ztensor(&amp;weights, weights_data_f, weights_data_i,\n                                  weights_data_c, weights_data_o);\n  assert(status == ZDNN_OK);\n\n  /***********************************************************************\n   * Create biases zTensors\n   * Resultant zTensors are concatenated\n   ***********************************************************************/\n\n  zdnn_tensor_desc biases_pre_tfrmd_desc, biases_tfrmd_desc;\n  zdnn_ztensor biases;\n\n  zdnn_init_pre_transformed_desc(ZDNN_2DS, type, &amp;biases_pre_tfrmd_desc,\n                                 num_dirs, num_hidden);\n  status = zdnn_generate_transformed_desc_concatenated(\n      &amp;biases_pre_tfrmd_desc, RNN_TYPE_LSTM | USAGE_BIASES | PREV_LAYER_NONE,\n      &amp;biases_tfrmd_desc);\n  assert(status == ZDNN_OK);\n\n  status = zdnn_init_ztensor_with_malloc(&amp;biases_pre_tfrmd_desc,\n                                         &amp;biases_tfrmd_desc, &amp;biases);\n  assert(status == ZDNN_OK);\n\n  uint64_t biases_data_size = num_hidden * element_size;\n  void *biases_data_f = malloc(biases_data_size);\n  void *biases_data_i = malloc(biases_data_size);\n  void *biases_data_c = malloc(biases_data_size);\n  void *biases_data_o = malloc(biases_data_size);\n\n  status = zdnn_transform_ztensor(&amp;biases, biases_data_f, biases_data_i,\n                                  biases_data_c, biases_data_o);\n  assert(status == ZDNN_OK);\n\n  /***********************************************************************\n   * Create hidden weights zTensor\n   * Resultant zTensor is concatenated\n   ***********************************************************************/\n\n  zdnn_tensor_desc hidden_weights_pre_tfrmd_desc, hidden_weights_tfrmd_desc;\n  zdnn_ztensor hidden_weights;\n\n  zdnn_init_pre_transformed_desc(ZDNN_3DS, type, &amp;hidden_weights_pre_tfrmd_desc,\n                                 num_dirs, num_hidden, num_hidden);\n  status = zdnn_generate_transformed_desc_concatenated(\n      &amp;hidden_weights_pre_tfrmd_desc,\n      RNN_TYPE_LSTM | USAGE_HIDDEN_WEIGHTS | PREV_LAYER_NONE,\n      &amp;hidden_weights_tfrmd_desc);\n  assert(status == ZDNN_OK);\n  status = zdnn_init_ztensor_with_malloc(&amp;hidden_weights_pre_tfrmd_desc,\n                                         &amp;hidden_weights_tfrmd_desc,\n                                         &amp;hidden_weights);\n  assert(status == ZDNN_OK);\n\n  uint64_t hidden_weights_data_size = num_hidden * num_hidden * element_size;\n  void *hidden_weights_data_f = malloc(hidden_weights_data_size);\n  void *hidden_weights_data_i = malloc(hidden_weights_data_size);\n  void *hidden_weights_data_c = malloc(hidden_weights_data_size);\n  void *hidden_weights_data_o = malloc(hidden_weights_data_size);\n\n  status = zdnn_transform_ztensor(&amp;hidden_weights, hidden_weights_data_f,\n                                  hidden_weights_data_i, hidden_weights_data_c,\n                                  hidden_weights_data_o);\n  assert(status == ZDNN_OK);\n\n  /***********************************************************************\n   * Create hidden biases zTensors\n   * Resultant zTensors are concatenated\n   ***********************************************************************/\n\n  zdnn_tensor_desc hidden_biases_pre_tfrmd_desc, hidden_biases_tfrmd_desc;\n  zdnn_ztensor hidden_biases;\n\n  zdnn_init_pre_transformed_desc(ZDNN_2DS, type, &amp;hidden_biases_pre_tfrmd_desc,\n                                 num_dirs, num_hidden);\n  status = zdnn_generate_transformed_desc_concatenated(\n      &amp;hidden_biases_pre_tfrmd_desc,\n      RNN_TYPE_LSTM | USAGE_HIDDEN_BIASES | PREV_LAYER_NONE,\n      &amp;hidden_biases_tfrmd_desc);\n  assert(status == ZDNN_OK);\n\n  status = zdnn_init_ztensor_with_malloc(\n      &amp;hidden_biases_pre_tfrmd_desc, &amp;hidden_biases_tfrmd_desc, &amp;hidden_biases);\n  assert(status == ZDNN_OK);\n\n  uint64_t hidden_biases_data_size = num_hidden * element_size;\n\n  void *hidden_biases_data_f = malloc(hidden_biases_data_size);\n  void *hidden_biases_data_i = malloc(hidden_biases_data_size);\n  void *hidden_biases_data_c = malloc(hidden_biases_data_size);\n  void *hidden_biases_data_o = malloc(hidden_biases_data_size);\n\n  status = zdnn_transform_ztensor(&amp;hidden_biases, hidden_biases_data_f,\n                                  hidden_biases_data_i, hidden_biases_data_c,\n                                  hidden_biases_data_o);\n  assert(status == ZDNN_OK);\n\n  /***********************************************************************\n   * Create output zTensor\n   ***********************************************************************/\n\n  zdnn_tensor_desc hn_pre_tfrmd_desc, hn_tfrmd_desc, cf_pre_tfrmd_desc,\n      cf_tfrmd_desc;\n\n  zdnn_ztensor hn_output_ztensor, cf_output_ztensor;\n\n  zdnn_init_pre_transformed_desc(ZDNN_4DS, type, &amp;hn_pre_tfrmd_desc,\n                                 num_timesteps, 2, num_batches, num_hidden);\n  status = zdnn_generate_transformed_desc(&amp;hn_pre_tfrmd_desc, &amp;hn_tfrmd_desc);\n  assert(status == ZDNN_OK);\n\n  zdnn_init_pre_transformed_desc(ZDNN_3DS, type, &amp;cf_pre_tfrmd_desc, 1, 2,\n                                 num_batches, num_hidden);\n  status = zdnn_generate_transformed_desc(&amp;cf_pre_tfrmd_desc, &amp;cf_tfrmd_desc);\n  assert(status == ZDNN_OK);\n\n  status = zdnn_init_ztensor_with_malloc(&amp;hn_pre_tfrmd_desc, &amp;hn_tfrmd_desc,\n                                         &amp;hn_output_ztensor);\n  assert(status == ZDNN_OK);\n  status = zdnn_init_ztensor_with_malloc(&amp;cf_pre_tfrmd_desc, &amp;cf_tfrmd_desc,\n                                         &amp;cf_output_ztensor);\n  assert(status == ZDNN_OK);\n\n  /***********************************************************************\n   * Call the AIU\n   ***********************************************************************/\n\n  void *work_area = NULL;\n\n  status = zdnn_lstm(&amp;input, &amp;h0, &amp;c0, &amp;weights, &amp;biases, &amp;hidden_weights,\n                     &amp;hidden_biases, dir, work_area, &amp;hn_output_ztensor,\n                     &amp;cf_output_ztensor);\n  assert(status == ZDNN_OK);\n\n  /***********************************************************************\n   * Output and Cleanup\n   ***********************************************************************/\n\n  uint64_t hn_data_size =\n      num_timesteps * 2 * num_batches * num_hidden * element_size;\n  uint64_t cf_data_size = 2 * num_batches * num_hidden * element_size;\n  void *hn_output_data = malloc(hn_data_size);\n  void *cf_output_data = malloc(cf_data_size);\n\n  status = zdnn_transform_origtensor(&amp;hn_output_ztensor, hn_output_data);\n  assert(status == ZDNN_OK);\n  status = zdnn_transform_origtensor(&amp;cf_output_ztensor, cf_output_data);\n  assert(status == ZDNN_OK);\n\n  status = zdnn_free_ztensor_buffer(&amp;input);\n  assert(status == ZDNN_OK);\n  status = zdnn_free_ztensor_buffer(&amp;h0);\n  assert(status == ZDNN_OK);\n  status = zdnn_free_ztensor_buffer(&amp;c0);\n  assert(status == ZDNN_OK);\n  status = zdnn_free_ztensor_buffer(&amp;weights);\n  assert(status == ZDNN_OK);\n  status = zdnn_free_ztensor_buffer(&amp;biases);\n  assert(status == ZDNN_OK);\n  status = zdnn_free_ztensor_buffer(&amp;hidden_weights);\n  assert(status == ZDNN_OK);\n  status = zdnn_free_ztensor_buffer(&amp;hidden_biases);\n  assert(status == ZDNN_OK);\n  status = zdnn_free_ztensor_buffer(&amp;hn_output_ztensor);\n  assert(status == ZDNN_OK);\n  status = zdnn_free_ztensor_buffer(&amp;cf_output_ztensor);\n  assert(status == ZDNN_OK);\n\n  free(input_data);\n  free(hidden_state_data);\n  free(cell_state_data);\n  free(weights_data_f);\n  free(weights_data_i);\n  free(weights_data_c);\n  free(weights_data_o);\n  free(hidden_weights_data_f);\n  free(hidden_weights_data_i);\n  free(hidden_weights_data_c);\n  free(hidden_weights_data_o);\n  free(biases_data_f);\n  free(biases_data_i);\n  free(biases_data_c);\n  free(biases_data_o);\n  free(hidden_biases_data_f);\n  free(hidden_biases_data_i);\n  free(hidden_biases_data_c);\n  free(hidden_biases_data_o);\n  free(hn_output_data);\n  free(cf_output_data);\n}\n</code></pre>"},{"location":"zDNN/#example-of-an-application-calling-the-zdnn_lstm-api-multi-layer-bi-directional","title":"Example of an application calling the zdnn_lstm API (multi-layer bi-directional)","text":"<p>Back to Table of Contents</p> <pre><code>// SPDX-License-Identifier: Apache-2.0\n/*\n\u00a0* Copyright IBM Corp. 2021\n\u00a0*\u00a0\n\u00a0* Licensed under the Apache License, Version 2.0 (the \"License\");\n\u00a0* you may not use this file except in compliance with the License.\n\u00a0* You may obtain a copy of the License at\n\u00a0*\u00a0\n\u00a0*\u00a0\u00a0\u00a0\u00a0 http://www.apache.org/licenses/LICENSE-2.0\n\u00a0*\u00a0\n\u00a0* Unless required by applicable law or agreed to in writing, software\n\u00a0* distributed under the License is distributed on an \"AS IS\" BASIS,\n\u00a0* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\u00a0* See the License for the specific language governing permissions and\n\u00a0* limitations under the License.\n\u00a0*/\n\n#include &lt;assert.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n\n#include \"zdnn.h\"\n\nvoid do_bidir_layer(zdnn_ztensor *input, uint32_t num_hidden,\n                    zdnn_ztensor *hn_output, bool is_prev_layer_bidir) {\n\n  zdnn_status status;\n\n  uint32_t num_batches = input-&gt;pre_transformed_desc-&gt;dim2;\n\n  // if input is bidir output from previous layer then number of features for\n  // this layer is 2x of hidden-state size (dim1) of the previous layer\n  uint32_t num_features =\n      input-&gt;pre_transformed_desc-&gt;dim1 * (is_prev_layer_bidir ? 2 : 1);\n\n  zdnn_data_types type = FP32;\n  short element_size = 4; // size of each element in bytes\n\n  lstm_gru_direction dir = BIDIR;\n  uint8_t num_dirs = 2;\n\n  /***********************************************************************\n   * Create initial hidden and cell state zTensors\n   ***********************************************************************/\n\n  zdnn_tensor_desc h0c0_pre_tfrmd_desc, h0c0_tfrmd_desc;\n  zdnn_ztensor h0, c0;\n\n  zdnn_init_pre_transformed_desc(ZDNN_3DS, type, &amp;h0c0_pre_tfrmd_desc, num_dirs,\n                                 num_batches, num_hidden);\n  status =\n      zdnn_generate_transformed_desc(&amp;h0c0_pre_tfrmd_desc, &amp;h0c0_tfrmd_desc);\n  assert(status == ZDNN_OK);\n\n  status = zdnn_init_ztensor_with_malloc(&amp;h0c0_pre_tfrmd_desc, &amp;h0c0_tfrmd_desc,\n                                         &amp;h0);\n  assert(status == ZDNN_OK);\n  status = zdnn_init_ztensor_with_malloc(&amp;h0c0_pre_tfrmd_desc, &amp;h0c0_tfrmd_desc,\n                                         &amp;c0);\n  assert(status == ZDNN_OK);\n\n  uint64_t h0c0_data_size = num_batches * num_hidden * element_size;\n  void *hidden_state_data = malloc(h0c0_data_size);\n  void *cell_state_data = malloc(h0c0_data_size);\n\n  status = zdnn_transform_ztensor(&amp;h0, hidden_state_data);\n  assert(status == ZDNN_OK);\n  status = zdnn_transform_ztensor(&amp;c0, cell_state_data);\n  assert(status == ZDNN_OK);\n\n  /***********************************************************************\n   * Create input weights zTensor\n   * Resultant zTensor is concatenated\n   ***********************************************************************/\n\n  zdnn_tensor_desc weights_pre_tfrmd_desc, weights_tfrmd_desc;\n  zdnn_ztensor weights;\n\n  // if using previous layer bidir output as input then number of features of\n  // this layer is\n  zdnn_init_pre_transformed_desc(ZDNN_3DS, type, &amp;weights_pre_tfrmd_desc,\n                                 num_dirs, num_features, num_hidden);\n  status = zdnn_generate_transformed_desc_concatenated(\n      &amp;weights_pre_tfrmd_desc,\n      RNN_TYPE_LSTM | USAGE_WEIGHTS |\n          (is_prev_layer_bidir ? PREV_LAYER_BIDIR : PREV_LAYER_UNI),\n      &amp;weights_tfrmd_desc);\n  assert(status == ZDNN_OK);\n\n  status = zdnn_init_ztensor_with_malloc(&amp;weights_pre_tfrmd_desc,\n                                         &amp;weights_tfrmd_desc, &amp;weights);\n  assert(status == ZDNN_OK);\n\n  uint64_t weights_data_size = num_features * num_hidden * element_size;\n  void *weights_data_f = malloc(weights_data_size);\n  void *weights_data_i = malloc(weights_data_size);\n  void *weights_data_c = malloc(weights_data_size);\n  void *weights_data_o = malloc(weights_data_size);\n\n  status = zdnn_transform_ztensor(&amp;weights, weights_data_f, weights_data_i,\n                                  weights_data_c, weights_data_o);\n  assert(status == ZDNN_OK);\n\n  /***********************************************************************\n   * Create biases zTensors\n   * Resultant zTensors are concatenated\n   ***********************************************************************/\n\n  zdnn_tensor_desc biases_pre_tfrmd_desc, biases_tfrmd_desc;\n  zdnn_ztensor biases;\n\n  zdnn_init_pre_transformed_desc(ZDNN_2DS, type, &amp;biases_pre_tfrmd_desc,\n                                 num_dirs, num_hidden);\n  status = zdnn_generate_transformed_desc_concatenated(\n      &amp;biases_pre_tfrmd_desc,\n      RNN_TYPE_LSTM | USAGE_BIASES |\n          (is_prev_layer_bidir ? PREV_LAYER_BIDIR : PREV_LAYER_UNI),\n      &amp;biases_tfrmd_desc);\n  assert(status == ZDNN_OK);\n\n  status = zdnn_init_ztensor_with_malloc(&amp;biases_pre_tfrmd_desc,\n                                         &amp;biases_tfrmd_desc, &amp;biases);\n  assert(status == ZDNN_OK);\n\n  uint64_t biases_data_size = num_hidden * element_size;\n  void *biases_data_f = malloc(biases_data_size);\n  void *biases_data_i = malloc(biases_data_size);\n  void *biases_data_c = malloc(biases_data_size);\n  void *biases_data_o = malloc(biases_data_size);\n\n  status = zdnn_transform_ztensor(&amp;biases, biases_data_f, biases_data_i,\n                                  biases_data_c, biases_data_o);\n  assert(status == ZDNN_OK);\n\n  /***********************************************************************\n   * Create hidden weights zTensor\n   * Resultant zTensor is concatenated\n   ***********************************************************************/\n\n  zdnn_tensor_desc hidden_weights_pre_tfrmd_desc, hidden_weights_tfrmd_desc;\n  zdnn_ztensor hidden_weights;\n\n  zdnn_init_pre_transformed_desc(ZDNN_3DS, type, &amp;hidden_weights_pre_tfrmd_desc,\n                                 num_dirs, num_hidden, num_hidden);\n  status = zdnn_generate_transformed_desc_concatenated(\n      &amp;hidden_weights_pre_tfrmd_desc,\n      RNN_TYPE_LSTM | USAGE_HIDDEN_WEIGHTS |\n          (is_prev_layer_bidir ? PREV_LAYER_BIDIR : PREV_LAYER_UNI),\n      &amp;hidden_weights_tfrmd_desc);\n  assert(status == ZDNN_OK);\n  status = zdnn_init_ztensor_with_malloc(&amp;hidden_weights_pre_tfrmd_desc,\n                                         &amp;hidden_weights_tfrmd_desc,\n                                         &amp;hidden_weights);\n  assert(status == ZDNN_OK);\n\n  uint64_t hidden_weights_data_size = num_hidden * num_hidden * element_size;\n  void *hidden_weights_data_f = malloc(hidden_weights_data_size);\n  void *hidden_weights_data_i = malloc(hidden_weights_data_size);\n  void *hidden_weights_data_c = malloc(hidden_weights_data_size);\n  void *hidden_weights_data_o = malloc(hidden_weights_data_size);\n\n  status = zdnn_transform_ztensor(&amp;hidden_weights, hidden_weights_data_f,\n                                  hidden_weights_data_i, hidden_weights_data_c,\n                                  hidden_weights_data_o);\n  assert(status == ZDNN_OK);\n\n  /***********************************************************************\n   * Create hidden biases zTensors\n   * Resultant zTensors are concatenated\n   ***********************************************************************/\n\n  zdnn_tensor_desc hidden_biases_pre_tfrmd_desc, hidden_biases_tfrmd_desc;\n  zdnn_ztensor hidden_biases;\n\n  zdnn_init_pre_transformed_desc(ZDNN_2DS, type, &amp;hidden_biases_pre_tfrmd_desc,\n                                 num_dirs, num_hidden);\n  status = zdnn_generate_transformed_desc_concatenated(\n      &amp;hidden_biases_pre_tfrmd_desc,\n      RNN_TYPE_LSTM | USAGE_HIDDEN_BIASES |\n          (is_prev_layer_bidir ? PREV_LAYER_BIDIR : PREV_LAYER_UNI),\n      &amp;hidden_biases_tfrmd_desc);\n  assert(status == ZDNN_OK);\n\n  status = zdnn_init_ztensor_with_malloc(\n      &amp;hidden_biases_pre_tfrmd_desc, &amp;hidden_biases_tfrmd_desc, &amp;hidden_biases);\n  assert(status == ZDNN_OK);\n\n  uint64_t hidden_biases_data_size = num_hidden * element_size;\n\n  void *hidden_biases_data_f = malloc(hidden_biases_data_size);\n  void *hidden_biases_data_i = malloc(hidden_biases_data_size);\n  void *hidden_biases_data_c = malloc(hidden_biases_data_size);\n  void *hidden_biases_data_o = malloc(hidden_biases_data_size);\n\n  status = zdnn_transform_ztensor(&amp;hidden_biases, hidden_biases_data_f,\n                                  hidden_biases_data_i, hidden_biases_data_c,\n                                  hidden_biases_data_o);\n  assert(status == ZDNN_OK);\n\n  /***********************************************************************\n   * Create cf output zTensor\n   ***********************************************************************/\n\n  zdnn_tensor_desc cf_pre_tfrmd_desc, cf_tfrmd_desc;\n\n  zdnn_ztensor cf_output_ztensor;\n\n  zdnn_init_pre_transformed_desc(ZDNN_4DS, type, &amp;cf_pre_tfrmd_desc, 1, 2,\n                                 num_batches, num_hidden);\n  status = zdnn_generate_transformed_desc(&amp;cf_pre_tfrmd_desc, &amp;cf_tfrmd_desc);\n  assert(status == ZDNN_OK);\n\n  status = zdnn_init_ztensor_with_malloc(&amp;cf_pre_tfrmd_desc, &amp;cf_tfrmd_desc,\n                                         &amp;cf_output_ztensor);\n  assert(status == ZDNN_OK);\n\n  /***********************************************************************\n   * Call the AIU\n   ***********************************************************************/\n\n  void *work_area = NULL;\n\n  status =\n      zdnn_lstm(input, &amp;h0, &amp;c0, &amp;weights, &amp;biases, &amp;hidden_weights,\n                &amp;hidden_biases, dir, work_area, hn_output, &amp;cf_output_ztensor);\n  assert(status == ZDNN_OK);\n\n  /***********************************************************************\n   * Cleanup and Return\n   ***********************************************************************/\n\n  status = zdnn_free_ztensor_buffer(&amp;h0);\n  assert(status == ZDNN_OK);\n  status = zdnn_free_ztensor_buffer(&amp;c0);\n  assert(status == ZDNN_OK);\n  status = zdnn_free_ztensor_buffer(&amp;weights);\n  assert(status == ZDNN_OK);\n  status = zdnn_free_ztensor_buffer(&amp;biases);\n  assert(status == ZDNN_OK);\n  status = zdnn_free_ztensor_buffer(&amp;hidden_weights);\n  assert(status == ZDNN_OK);\n  status = zdnn_free_ztensor_buffer(&amp;hidden_biases);\n  assert(status == ZDNN_OK);\n  status = zdnn_free_ztensor_buffer(&amp;cf_output_ztensor);\n  assert(status == ZDNN_OK);\n\n  free(hidden_state_data);\n  free(cell_state_data);\n  free(weights_data_f);\n  free(weights_data_i);\n  free(weights_data_c);\n  free(weights_data_o);\n  free(hidden_weights_data_f);\n  free(hidden_weights_data_i);\n  free(hidden_weights_data_c);\n  free(hidden_weights_data_o);\n  free(biases_data_f);\n  free(biases_data_i);\n  free(biases_data_c);\n  free(biases_data_o);\n  free(hidden_biases_data_f);\n  free(hidden_biases_data_i);\n  free(hidden_biases_data_c);\n  free(hidden_biases_data_o);\n}\n\n// Sample: LSTM multi-layer BIDIR\nint main(int argc, char *argv[]) {\n  zdnn_status status;\n\n#ifdef STATIC_LIB\n  zdnn_init();\n#endif\n\n  uint32_t num_hidden[2] = {5, 4};\n\n  /***********************************************************************\n   * Create input zTensor\n   ***********************************************************************/\n\n  zdnn_tensor_desc input_pre_tfrmd_desc, input_tfrmd_desc;\n  zdnn_ztensor input;\n\n  uint32_t num_timesteps = 5;\n  uint32_t num_batches = 3;\n  uint32_t num_features = 32;\n\n  zdnn_data_types type = FP32;\n  short element_size = 4; // size of each element in bytes\n\n  zdnn_init_pre_transformed_desc(ZDNN_3DS, type, &amp;input_pre_tfrmd_desc,\n                                 num_timesteps, num_batches, num_features);\n  status =\n      zdnn_generate_transformed_desc(&amp;input_pre_tfrmd_desc, &amp;input_tfrmd_desc);\n  assert(status == ZDNN_OK);\n  status = zdnn_init_ztensor_with_malloc(&amp;input_pre_tfrmd_desc,\n                                         &amp;input_tfrmd_desc, &amp;input);\n  assert(status == ZDNN_OK);\n\n  uint64_t input_data_size =\n      num_timesteps * num_batches * num_features * element_size;\n  void *input_data = malloc(input_data_size);\n\n  status = zdnn_transform_ztensor(&amp;input, input_data);\n  assert(status == ZDNN_OK);\n\n  /***********************************************************************\n   * Create 2 hn output zTensors\n   ***********************************************************************/\n\n  zdnn_tensor_desc hn_pre_tfrmd_desc[2], hn_tfrmd_desc[2];\n  zdnn_ztensor hn_output[2];\n\n  for (int i = 0; i &lt; 2; i++) {\n    zdnn_init_pre_transformed_desc(ZDNN_4DS, type, &amp;hn_pre_tfrmd_desc[i],\n                                   num_timesteps, 2, num_batches,\n                                   num_hidden[i]);\n    status = zdnn_generate_transformed_desc(&amp;hn_pre_tfrmd_desc[i],\n                                            &amp;hn_tfrmd_desc[i]);\n    assert(status == ZDNN_OK);\n\n    status = zdnn_init_ztensor_with_malloc(&amp;hn_pre_tfrmd_desc[i],\n                                           &amp;hn_tfrmd_desc[i], &amp;hn_output[i]);\n    assert(status == ZDNN_OK);\n  }\n\n  /***********************************************************************\n   * Do the layers\n   ***********************************************************************/\n\n  // call the first layer with input, previous layer bidir = false, output goes\n  // to hn_output[0]\n  do_bidir_layer(&amp;input, num_hidden[0], &amp;hn_output[0], false);\n\n  // call the second layer with hn_output[0] from layer 1, previous layer bidir\n  // = true, output goes to hn_output[1]\n  do_bidir_layer(&amp;hn_output[0], num_hidden[1], &amp;hn_output[1], true);\n\n  /***********************************************************************\n   * Output and Cleanup\n   ***********************************************************************/\n\n  void *hn_output_data[2];\n\n  for (int i = 0; i &lt; 2; i++) {\n    uint64_t hn_output_data_size = (uint64_t)num_timesteps * num_batches *\n                                   num_hidden[i] * 2 * element_size;\n    hn_output_data[i] = malloc(hn_output_data_size);\n\n    status = zdnn_transform_origtensor(&amp;hn_output[i], hn_output_data[i]);\n    assert(status == ZDNN_OK);\n  }\n\n  status = zdnn_free_ztensor_buffer(&amp;input);\n  assert(status == ZDNN_OK);\n  status = zdnn_free_ztensor_buffer(&amp;hn_output[0]);\n  assert(status == ZDNN_OK);\n  status = zdnn_free_ztensor_buffer(&amp;hn_output[1]);\n  assert(status == ZDNN_OK);\n\n  free(input_data);\n  free(hn_output_data[0]);\n  free(hn_output_data[1]);\n}\n</code></pre>"},{"location":"zDNN/#example-of-an-application-calling-the-zdnn_gru-api-forward","title":"Example of an application calling the zdnn_gru API (forward)","text":"<p>Back to Table of Contents</p> <pre><code>// SPDX-License-Identifier: Apache-2.0\n/*\n\u00a0* Copyright IBM Corp. 2021\n\u00a0*\u00a0\n\u00a0* Licensed under the Apache License, Version 2.0 (the \"License\");\n\u00a0* you may not use this file except in compliance with the License.\n\u00a0* You may obtain a copy of the License at\n\u00a0*\u00a0\n\u00a0*\u00a0\u00a0\u00a0\u00a0 http://www.apache.org/licenses/LICENSE-2.0\n\u00a0*\u00a0\n\u00a0* Unless required by applicable law or agreed to in writing, software\n\u00a0* distributed under the License is distributed on an \"AS IS\" BASIS,\n\u00a0* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\u00a0* See the License for the specific language governing permissions and\n\u00a0* limitations under the License.\n\u00a0*/\n\n#include &lt;assert.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n\n#include \"zdnn.h\"\n\n// Sample: GRU\nint main(int argc, char *argv[]) {\n  zdnn_status status;\n\n#ifdef STATIC_LIB\n  zdnn_init();\n#endif\n\n  /***********************************************************************\n   *\n   * GRU (FWD/BWD):\n   *\n   * INPUTS --------------------------------------------------------------\n   * input           |  ZDNN_3DS  | (num_timesteps, num_batches, num_features)\n   * h0              |  ZDNN_3DS  | (1, num_batches, num_hidden)\n   * weights         |  ZDNN_3DS  | (1, num_features, num_hidden)\n   * input_biases    |  ZDNN_2DS  | (1, num_hidden)\n   * hidden_weights  |  ZDNN_3DS  | (1, num_hidden, num_hidden)\n   * hidden_biases   |  ZDNN_2DS  | (1, num_hidden)\n   *\n   * OUTPUTS -------------------------------------------------------------\n   * hn_output       |  ZDNN_4DS  | (num_timesteps, 1, num_batches, num_hidden)\n   *                 |            | or (1, 1, num_batches, num_hidden)\n   ***********************************************************************/\n\n  /***********************************************************************\n   * Create input zTensor\n   ***********************************************************************/\n\n  zdnn_tensor_desc input_pre_tfrmd_desc, input_tfrmd_desc;\n  zdnn_ztensor input;\n\n  uint32_t num_timesteps = 5;\n  uint32_t num_batches = 3;\n  uint32_t num_features = 32;\n  uint32_t num_hidden = 5;\n\n  zdnn_data_types type = FP32;\n  short element_size = 4; // size of each element in bytes\n\n  lstm_gru_direction dir = FWD;\n  uint8_t num_dirs = 1;\n\n  zdnn_init_pre_transformed_desc(ZDNN_3DS, type, &amp;input_pre_tfrmd_desc,\n                                 num_timesteps, num_batches, num_features);\n  status =\n      zdnn_generate_transformed_desc(&amp;input_pre_tfrmd_desc, &amp;input_tfrmd_desc);\n  assert(status == ZDNN_OK);\n  status = zdnn_init_ztensor_with_malloc(&amp;input_pre_tfrmd_desc,\n                                         &amp;input_tfrmd_desc, &amp;input);\n  assert(status == ZDNN_OK);\n\n  uint64_t input_data_size =\n      num_timesteps * num_batches * num_features * element_size;\n  void *input_data = malloc(input_data_size);\n\n  status = zdnn_transform_ztensor(&amp;input, input_data);\n  assert(status == ZDNN_OK);\n\n  /***********************************************************************\n   * Create initial hidden zTensor\n   ***********************************************************************/\n\n  zdnn_tensor_desc h0_pre_tfrmd_desc, h0_tfrmd_desc;\n  zdnn_ztensor h0;\n\n  zdnn_init_pre_transformed_desc(ZDNN_3DS, type, &amp;h0_pre_tfrmd_desc, num_dirs,\n                                 num_batches, num_hidden);\n  status = zdnn_generate_transformed_desc(&amp;h0_pre_tfrmd_desc, &amp;h0_tfrmd_desc);\n  assert(status == ZDNN_OK);\n\n  status =\n      zdnn_init_ztensor_with_malloc(&amp;h0_pre_tfrmd_desc, &amp;h0_tfrmd_desc, &amp;h0);\n  assert(status == ZDNN_OK);\n\n  uint64_t h0_data_size = num_batches * num_hidden * element_size;\n  void *hidden_state_data = malloc(h0_data_size);\n\n  status = zdnn_transform_ztensor(&amp;h0, hidden_state_data);\n  assert(status == ZDNN_OK);\n\n  /***********************************************************************\n   * Create input weights zTensor\n   * Resultant zTensor is concatenated\n   ***********************************************************************/\n\n  zdnn_tensor_desc weights_pre_tfrmd_desc, weights_tfrmd_desc;\n  zdnn_ztensor weights;\n\n  zdnn_init_pre_transformed_desc(ZDNN_3DS, type, &amp;weights_pre_tfrmd_desc,\n                                 num_dirs, num_features, num_hidden);\n  status = zdnn_generate_transformed_desc_concatenated(\n      &amp;weights_pre_tfrmd_desc, RNN_TYPE_GRU | USAGE_WEIGHTS | PREV_LAYER_NONE,\n      &amp;weights_tfrmd_desc);\n  assert(status == ZDNN_OK);\n\n  status = zdnn_init_ztensor_with_malloc(&amp;weights_pre_tfrmd_desc,\n                                         &amp;weights_tfrmd_desc, &amp;weights);\n  assert(status == ZDNN_OK);\n\n  uint64_t weights_data_size = num_features * num_hidden * element_size;\n  void *weights_data_z = malloc(weights_data_size);\n  void *weights_data_r = malloc(weights_data_size);\n  void *weights_data_h = malloc(weights_data_size);\n\n  status = zdnn_transform_ztensor(&amp;weights, weights_data_z, weights_data_r,\n                                  weights_data_h);\n  assert(status == ZDNN_OK);\n\n  /***********************************************************************\n   * Create biases zTensors\n   * Resultant zTensors are concatenated\n   ***********************************************************************/\n\n  zdnn_tensor_desc biases_pre_tfrmd_desc, biases_tfrmd_desc;\n  zdnn_ztensor biases;\n\n  zdnn_init_pre_transformed_desc(ZDNN_2DS, type, &amp;biases_pre_tfrmd_desc,\n                                 num_dirs, num_hidden);\n  status = zdnn_generate_transformed_desc_concatenated(\n      &amp;biases_pre_tfrmd_desc, RNN_TYPE_GRU | USAGE_BIASES | PREV_LAYER_NONE,\n      &amp;biases_tfrmd_desc);\n  assert(status == ZDNN_OK);\n\n  status = zdnn_init_ztensor_with_malloc(&amp;biases_pre_tfrmd_desc,\n                                         &amp;biases_tfrmd_desc, &amp;biases);\n  assert(status == ZDNN_OK);\n\n  uint64_t biases_data_size = num_hidden * element_size;\n  void *biases_data_z = malloc(biases_data_size);\n  void *biases_data_r = malloc(biases_data_size);\n  void *biases_data_h = malloc(biases_data_size);\n\n  status = zdnn_transform_ztensor(&amp;biases, biases_data_z, biases_data_r,\n                                  biases_data_h);\n  assert(status == ZDNN_OK);\n\n  /***********************************************************************\n   * Create hidden weights zTensor\n   * Resultant zTensor is concatenated\n   ***********************************************************************/\n\n  zdnn_tensor_desc hidden_weights_pre_tfrmd_desc, hidden_weights_tfrmd_desc;\n  zdnn_ztensor hidden_weights;\n\n  zdnn_init_pre_transformed_desc(ZDNN_3DS, type, &amp;hidden_weights_pre_tfrmd_desc,\n                                 num_dirs, num_hidden, num_hidden);\n  status = zdnn_generate_transformed_desc_concatenated(\n      &amp;hidden_weights_pre_tfrmd_desc,\n      RNN_TYPE_GRU | USAGE_HIDDEN_WEIGHTS | PREV_LAYER_NONE,\n      &amp;hidden_weights_tfrmd_desc);\n  assert(status == ZDNN_OK);\n  status = zdnn_init_ztensor_with_malloc(&amp;hidden_weights_pre_tfrmd_desc,\n                                         &amp;hidden_weights_tfrmd_desc,\n                                         &amp;hidden_weights);\n  assert(status == ZDNN_OK);\n\n  uint64_t hidden_weights_data_size = num_hidden * num_hidden * element_size;\n  void *hidden_weights_data_z = malloc(hidden_weights_data_size);\n  void *hidden_weights_data_r = malloc(hidden_weights_data_size);\n  void *hidden_weights_data_h = malloc(hidden_weights_data_size);\n\n  status = zdnn_transform_ztensor(&amp;hidden_weights, hidden_weights_data_z,\n                                  hidden_weights_data_r, hidden_weights_data_h);\n  assert(status == ZDNN_OK);\n\n  /***********************************************************************\n   * Create hidden biases zTensors\n   * Resultant zTensors are concatenated\n   ***********************************************************************/\n\n  zdnn_tensor_desc hidden_biases_pre_tfrmd_desc, hidden_biases_tfrmd_desc;\n  zdnn_ztensor hidden_biases;\n\n  zdnn_init_pre_transformed_desc(ZDNN_2DS, type, &amp;hidden_biases_pre_tfrmd_desc,\n                                 num_dirs, num_hidden);\n  status = zdnn_generate_transformed_desc_concatenated(\n      &amp;hidden_biases_pre_tfrmd_desc,\n      RNN_TYPE_GRU | USAGE_HIDDEN_BIASES | PREV_LAYER_NONE,\n      &amp;hidden_biases_tfrmd_desc);\n  assert(status == ZDNN_OK);\n\n  status = zdnn_init_ztensor_with_malloc(\n      &amp;hidden_biases_pre_tfrmd_desc, &amp;hidden_biases_tfrmd_desc, &amp;hidden_biases);\n  assert(status == ZDNN_OK);\n\n  uint64_t hidden_biases_data_size = num_hidden * element_size;\n  void *hidden_biases_data_z = malloc(hidden_biases_data_size);\n  void *hidden_biases_data_r = malloc(hidden_biases_data_size);\n  void *hidden_biases_data_h = malloc(hidden_biases_data_size);\n\n  status = zdnn_transform_ztensor(&amp;hidden_biases, hidden_biases_data_z,\n                                  hidden_biases_data_r, hidden_biases_data_h);\n  assert(status == ZDNN_OK);\n\n  /***********************************************************************\n   * Create output zTensor\n   ***********************************************************************/\n\n  // get only the last timestep\n  zdnn_tensor_desc hn_pre_tfrmd_desc, hn_tfrmd_desc;\n\n  zdnn_ztensor hn_output_ztensor;\n\n  zdnn_init_pre_transformed_desc(ZDNN_4DS, type, &amp;hn_pre_tfrmd_desc, 1, 1,\n                                 num_batches, num_hidden);\n  status = zdnn_generate_transformed_desc(&amp;hn_pre_tfrmd_desc, &amp;hn_tfrmd_desc);\n  assert(status == ZDNN_OK);\n\n  status = zdnn_init_ztensor_with_malloc(&amp;hn_pre_tfrmd_desc, &amp;hn_tfrmd_desc,\n                                         &amp;hn_output_ztensor);\n  assert(status == ZDNN_OK);\n\n  /***********************************************************************\n   * Call the AIU\n   ***********************************************************************/\n\n  void *work_area = NULL;\n\n  status = zdnn_gru(&amp;input, &amp;h0, &amp;weights, &amp;biases, &amp;hidden_weights,\n                    &amp;hidden_biases, dir, work_area, &amp;hn_output_ztensor);\n  assert(status == ZDNN_OK);\n\n  /***********************************************************************\n   * Output and Cleanup\n   ***********************************************************************/\n\n  uint64_t hn_data_size = num_batches * num_hidden * element_size;\n  void *hn_output_data = malloc(hn_data_size);\n\n  status = zdnn_transform_origtensor(&amp;hn_output_ztensor, hn_output_data);\n  assert(status == ZDNN_OK);\n\n  status = zdnn_free_ztensor_buffer(&amp;input);\n  assert(status == ZDNN_OK);\n  status = zdnn_free_ztensor_buffer(&amp;h0);\n  assert(status == ZDNN_OK);\n  status = zdnn_free_ztensor_buffer(&amp;weights);\n  assert(status == ZDNN_OK);\n  status = zdnn_free_ztensor_buffer(&amp;biases);\n  assert(status == ZDNN_OK);\n  status = zdnn_free_ztensor_buffer(&amp;hidden_weights);\n  assert(status == ZDNN_OK);\n  status = zdnn_free_ztensor_buffer(&amp;hidden_biases);\n  assert(status == ZDNN_OK);\n  status = zdnn_free_ztensor_buffer(&amp;hn_output_ztensor);\n  assert(status == ZDNN_OK);\n\n  free(input_data);\n  free(hidden_state_data);\n  free(weights_data_z);\n  free(weights_data_r);\n  free(weights_data_h);\n  free(hidden_weights_data_z);\n  free(hidden_weights_data_r);\n  free(hidden_weights_data_h);\n  free(biases_data_z);\n  free(biases_data_r);\n  free(biases_data_h);\n  free(hidden_biases_data_z);\n  free(hidden_biases_data_r);\n  free(hidden_biases_data_h);\n  free(hn_output_data);\n}\n</code></pre>"},{"location":"zDNN/CONTRIBUTING/","title":"Contributing to zDNN","text":""},{"location":"zDNN/CONTRIBUTING/#license","title":"License","text":"<p>All contributions have to be submitted under the Apache 2.0 license. See also the LICENSE file.</p>"},{"location":"zDNN/CONTRIBUTING/#developers-certificate-of-origin-and-signed-off-by","title":"Developer's Certificate of Origin and Signed-off-by","text":"<p>The sign-off is a simple line at the end of the explanation for the patch, which certifies that you wrote it or otherwise have the right to pass it on as an open-source patch.</p> <p>With the Signed-off-by line you certify the below:</p> <pre><code>Developer's Certificate of Origin 1.1\n\n       By making a contribution to this project, I certify that:\n\n       (a) The contribution was created in whole or in part by me and I\n           have the right to submit it under the open source license\n           indicated in the file; or\n\n       (b) The contribution is based upon previous work that, to the best\n           of my knowledge, is covered under an appropriate open source\n           license and I have the right under that license to submit that\n           work with modifications, whether created in whole or in part\n           by me, under the same open source license (unless I am\n           permitted to submit under a different license), as indicated\n           in the file; or\n\n       (c) The contribution was provided directly to me by some other\n           person who certified (a), (b) or (c) and I have not modified\n           it.\n\n       (d) I understand and agree that this project and the contribution\n           are public and that a record of the contribution (including all\n           personal information I submit with it, including my sign-off) is\n           maintained indefinitely and may be redistributed consistent with\n           this project or the open source license(s) involved.\n</code></pre> <p>If you can certify the above, just add a line stating the following at the bottom of each of your commit messages:</p> <pre><code>Signed-off-by: Random Developer &lt;random@developer.example.org&gt;\n</code></pre> <p>Please use your real name and a valid e-mail address (no pseudonyms or anonymous contributions).</p>"},{"location":"zDNN/CONTRIBUTING/#submitting-code","title":"Submitting code","text":"<p>The preferred way is to create GitHub pull requests for your code contributions. Please create separate pull requests for each logical enhancement, new feature, or fix.</p>"},{"location":"zDNN/CONTRIBUTING/#github-workflow-for-contributions","title":"GitHub workflow for contributions","text":"<p>In the examples below we use this fictive identity:</p> <ul> <li>Name: Random Developer</li> <li>E-mail: random@developer.example.org</li> <li>GitHub ID: random-developer</li> </ul>"},{"location":"zDNN/CONTRIBUTING/#setup-github-and-local-git","title":"Setup GitHub and local git","text":"<ol> <li> <p>Create a fork of this repository by clicking the <code>Fork</code> button on the top    right of the zDNN    main page</p> </li> <li> <p>Clone your forked repository to your local development system    <pre><code>$ git clone https://github.com/random-developer/zDNN.git\n</code></pre></p> </li> <li> <p>Configure a remote called \"upstream\" pointing to the official    zDNN repository on GitHub    <pre><code>$ cd zDNN\n~/zDNN $ git remote add upstream https://github.com/IBM/zDNN.git\n</code></pre></p> </li> <li> <p>Verify your remotes    <pre><code>~/zDNN $ git remote -v\norigin  https://github.com/random-developer/zDNN.git (fetch)\norigin  https://github.com/random-developer/zDNN.git (push)\nupstream        https://github.com/IBM/zDNN.git (fetch)\nupstream        https://github.com/IBM/zDNN.git (push)\n</code></pre>    You now have two remotes: The \"origin\" remote points to your fork    and the \"upstream\" remote to the official zDNN repository.</p> </li> <li> <p>Configure your git user name and e-mail    <pre><code>~/zDNN $ git config user.name \"Random Developer\"\n~/zDNN $ git config user.email \"random@developer.example.com\"\n</code></pre></p> </li> </ol>"},{"location":"zDNN/CONTRIBUTING/#create-a-pull-request","title":"Create a pull request","text":"<ol> <li> <p>Create and checkout a new branch for your contribution    <pre><code>~/zDNN $ git checkout -b contrib-doc-pr\n</code></pre></p> </li> <li> <p>Make your changes to the code    <pre><code>~/zDNN $ vim CONTRIBUTING.md\n</code></pre></p> </li> <li> <p>Build and test your contribution, recommended on NNPA enabled machine.    <pre><code>~/zDNN $ make clean all\n</code></pre></p> </li> <li> <p>Commit your changes    <pre><code>~/zDNN $ git add CONTRIBUTING.md\n~/zDNN $ git commit -s\n</code></pre></p> </li> </ol> <p>Provide a meaningful commit message including your \"Signed-off-by\" line to    each commit:    <pre><code>CONTRIBUTING: Outline steps to submit code\n\nExplain in more detail how to submit zDNN contributions as GitHub\npull requests.\n\nSigned-off-by: Random Developer &lt;random@developer.example.com&gt;\n</code></pre></p> <ol> <li> <p>Push the changes to your fork of the repository    <pre><code>~/zDNN $ git push origin contrib-doc-pr\n</code></pre></p> </li> <li> <p>Go to the GitHub website of your zDNN fork and create a pull request    for your branch \"contrib-doc-pr\"</p> </li> </ol>"},{"location":"zDNN/CONTRIBUTING/#update-a-pull-request-during-review","title":"Update a pull request during review","text":"<p>If there are changes requested during the review process, you have to update your code in the pull request.</p> <p>To retain the existing review comments, add commits on top of your pull request branch. Depending on the size and number of changes, a rebase of the pull request might be required. This will be communicated during the review.</p> <ol> <li> <p>Update your code with new commits    <pre><code>~/zDNN $ vi CONTRIBUTING.md\n~/zDNN $ git add CONTRIBUTING.md\n~/zDNN $ git commit -s -m \"CONTRIBUTING: Add update PR info\"\n</code></pre></p> </li> <li> <p>Update your pull request by pushing changes    <pre><code>~/zDNN $ git push origin contrib-doc-pr\n</code></pre></p> </li> </ol>"},{"location":"zDNN/CONTRIBUTING/#finalize-a-pull-request","title":"Finalize a pull request","text":"<p>After the review process is finished or if you are explicitly asked for it, you have to create a clean commit series.</p> <ol> <li> <p>Save branch to \"contrib-doc-pr.v1\"    <pre><code>$ cd zDNN\n~/zDNN $ git branch contrib-doc-pr.v1\n</code></pre></p> </li> <li> <p>Use interactive git rebase to merge commits, adjust commit messages,    and rebase onto your local main branch    <pre><code>~/zDNN $ git rebase -i main\n</code></pre></p> </li> </ol> <p>An editor is started and shows the following:    <pre><code>pick 2c73b9fc CONTRIBUTING: Outline steps to submit code\npick fcfb0412 CONTRIBUTING: Add update PR info\n</code></pre></p> <p>To merge the update into the original commit, replace \"pick fcfb0412\"    with \"squash fcfb0412\".</p> <pre><code>pick 2c73b9fc CONTRIBUTING: Outline steps to submit code\nsquash fcfb0412 CONTRIBUTING: Add update PR info\n</code></pre> <p>Save the document and exit the editor to finish the merge. Another editor    window is presented to modify the commit message.</p> <p>You now could change the commit message as follows:</p> <pre><code>CONTRIBUTING: Outline steps to submit code\n\nExplain in more detail how to submit zDNN contributions as GitHub\npull requests and how to update already submitted pull requests.\n\nSigned-off-by: Random Developer &lt;random@developer.example.com&gt;\n</code></pre> <p>With interactive rebasing you can also change the order of commits and    modify commit messages with \"reword\".</p> <ol> <li>Use <code>git push</code> with the force option to replace the existing pull request    with your locally modified commits    <pre><code>~/zDNN $ git push --force origin contrib-doc-pr\n</code></pre></li> </ol>"},{"location":"zDNN/CONTRIBUTING/#rebase-a-pull-request","title":"Rebase a pull request","text":"<p>If changes are made to the main branch in the official zDNN repository you may be asked to rebase your branch with your contribution onto it. This can be required to prevent any merge conflicts that might arise when integrating your contribution.</p> <ol> <li> <p>Fetch all upstream changes from the official zDNN repository,    rebase your local main branch and update the main branch    on your fork    <pre><code>~/zDNN $ git fetch upstream\n~/zDNN $ git checkout main\n~/zDNN $ git rebase upstream/main\n~/zDNN $ git push origin main\n</code></pre></p> </li> <li> <p>Rebase your branch with your contribution onto the main branch of    the official zDNN repository    <pre><code>~/zDNN $ git checkout contrib-doc-pr\n~/zDNN $ git rebase main\n</code></pre></p> </li> <li> <p>Use <code>git push</code> with the force option to replace the existing pull    request with your locally modified commits    <pre><code>~/zDNN $ git push --force origin contrib-doc-pr\n</code></pre></p> </li> </ol>"},{"location":"zDNN/samples/","title":"Samples","text":""},{"location":"zDNN/samples/#compile","title":"Compile","text":"<p>Assume current directroy is <code>/samples</code></p> <p>z/OS:</p> <pre><code>xlc  -g3 -qlanglvl=extc99 -Wc,LP64 -I ../zdnn -o simple_add simple_add.c ../zdnn/lib/libzdnn.x\n</code></pre> <p>Linux's:</p> <pre><code>gcc -g3 -Wall -fmessage-length=0 -std=c99 -I ../zdnn -o simple_add simple_add.c  ../zdnn/lib/libzdnn.so\n</code></pre>"},{"location":"zDNN/samples/#note-add-d-static_lib-to-gcc-invocation-if-youre-compiling-using-statically-linked-library","title":"NOTE: Add <code>-D STATIC_LIB</code> to gcc invocation if you're compiling using statically-linked library","text":""}]}